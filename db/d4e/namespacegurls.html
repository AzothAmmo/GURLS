<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GURLS++: gurls Namespace Reference</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GURLS++
   &#160;<span id="projectnumber">2.0.00</span>
   </div>
   <div id="projectbrief">C++ Implementation of GURLS Matlab Toolbox</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('db/d4e/namespacegurls.html','../../');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gurls Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main namespace of GURLS++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d2a/classgurls_1_1_bad_confidence_creation.html">BadConfidenceCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/d2a/classgurls_1_1_bad_confidence_creation.html" title="BadConfidenceCreation is thrown when factory tries to generate an unknown confidence method...">BadConfidenceCreation</a> is thrown when factory tries to generate an unknown confidence method.  <a href="../../d3/d2a/classgurls_1_1_bad_confidence_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d16/classgurls_1_1_bad_kernel_creation.html">BadKernelCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d16/classgurls_1_1_bad_kernel_creation.html" title="BadKernelCreation is thrown when factory tries to generate an unknown kernel.">BadKernelCreation</a> is thrown when factory tries to generate an unknown kernel.  <a href="../../da/d16/classgurls_1_1_bad_kernel_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d93/classgurls_1_1_bad_norm_creation.html">BadNormCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d93/classgurls_1_1_bad_norm_creation.html" title="BadNormCreation is thrown when factory tries to generate an unknown norm.">BadNormCreation</a> is thrown when factory tries to generate an unknown norm.  <a href="../../dc/d93/classgurls_1_1_bad_norm_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d0d/classgurls_1_1_bad_optimizer_creation.html">BadOptimizerCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d0d/classgurls_1_1_bad_optimizer_creation.html" title="BadOptimizerCreation is thrown when factory tries to generate an unknown optimizer.">BadOptimizerCreation</a> is thrown when factory tries to generate an unknown optimizer.  <a href="../../d1/d0d/classgurls_1_1_bad_optimizer_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc4/classgurls_1_1_bad_param_selection_creation.html">BadParamSelectionCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/dc4/classgurls_1_1_bad_param_selection_creation.html" title="BadParamSelectionCreation is thrown when factory tries to generate an unknown parameter selection met...">BadParamSelectionCreation</a> is thrown when factory tries to generate an unknown parameter selection method.  <a href="../../d9/dc4/classgurls_1_1_bad_param_selection_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/classgurls_1_1_bad_performance_creation.html">BadPerformanceCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/ddf/classgurls_1_1_bad_performance_creation.html" title="BadPerformanceCreation is thrown when factory tries to generate an unknown performance evaluator...">BadPerformanceCreation</a> is thrown when factory tries to generate an unknown performance evaluator.  <a href="../../dd/ddf/classgurls_1_1_bad_performance_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd1/classgurls_1_1_bad_prediction_creation.html">BadPredictionCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/dd1/classgurls_1_1_bad_prediction_creation.html" title="BadPredictionCreation is thrown when factory tries to generate an unknown prediction method...">BadPredictionCreation</a> is thrown when factory tries to generate an unknown prediction method.  <a href="../../d4/dd1/classgurls_1_1_bad_prediction_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5f/classgurls_1_1_bad_pred_kernel_creation.html">BadPredKernelCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/d5f/classgurls_1_1_bad_pred_kernel_creation.html" title="BadPredKernelCreation is thrown when factory tries to generate an unknown prediction kernel...">BadPredKernelCreation</a> is thrown when factory tries to generate an unknown prediction kernel.  <a href="../../d8/d5f/classgurls_1_1_bad_pred_kernel_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5c/classgurls_1_1_bad_split_creation.html">BadSplitCreation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d7/d5c/classgurls_1_1_bad_split_creation.html" title="BadSplitCreation is thrown when factory tries to generate an unknown split method.">BadSplitCreation</a> is thrown when factory tries to generate an unknown split method.  <a href="../../d7/d5c/classgurls_1_1_bad_split_creation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8b/classgurls_1_1_base_array.html">BaseArray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/d8b/classgurls_1_1_base_array.html" title="BaseArray is the base class for all classes implementing vectors and matrices as arrays of cells...">BaseArray</a> is the base class for all classes implementing vectors and matrices as arrays of cells.  <a href="../../d9/d8b/classgurls_1_1_base_array.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfd/classgurls_1_1_blas_utils.html">BlasUtils</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/dfd/classgurls_1_1_blas_utils.html" title="BlasUtils is a convenience class to interface with Blas.">BlasUtils</a> is a convenience class to interface with Blas.  <a href="../../da/dfd/classgurls_1_1_blas_utils.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d88/classgurls_1_1_conf_boltzman.html">ConfBoltzman</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/d88/classgurls_1_1_conf_boltzman.html" title="ConfBoltzman is the sub-class of Confidence that computes the probability of belonging to the highest...">ConfBoltzman</a> is the sub-class of <a class="el" href="../../da/d7d/classgurls_1_1_confidence.html" title="Confidence is the class that computes a confidence score for the predicted labels.">Confidence</a> that computes the probability of belonging to the highest scoring class.  <a href="../../dd/d88/classgurls_1_1_conf_boltzman.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d77/classgurls_1_1_conf_boltzman_gap.html">ConfBoltzmanGap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d77/classgurls_1_1_conf_boltzman_gap.html" title="ConfBoltzmanGap is the sub-class of Confidence that computes a confidence estimation for the predicte...">ConfBoltzmanGap</a> is the sub-class of <a class="el" href="../../da/d7d/classgurls_1_1_confidence.html" title="Confidence is the class that computes a confidence score for the predicted labels.">Confidence</a> that computes a confidence estimation for the predicted class (i.e.  <a href="../../d0/d77/classgurls_1_1_conf_boltzman_gap.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbc/classgurls_1_1_conf_gap.html">ConfGap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/dbc/classgurls_1_1_conf_gap.html" title="ConfGap is the sub-class of Confidence that computes a confidence estimation for the predicted class...">ConfGap</a> is the sub-class of <a class="el" href="../../da/d7d/classgurls_1_1_confidence.html" title="Confidence is the class that computes a confidence score for the predicted labels.">Confidence</a> that computes a confidence estimation for the predicted class.  <a href="../../d8/dbc/classgurls_1_1_conf_gap.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7d/classgurls_1_1_confidence.html">Confidence</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d7d/classgurls_1_1_confidence.html" title="Confidence is the class that computes a confidence score for the predicted labels.">Confidence</a> is the class that computes a confidence score for the predicted labels.  <a href="../../da/d7d/classgurls_1_1_confidence.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ded/classgurls_1_1_conf_max_score.html">ConfMaxScore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/ded/classgurls_1_1_conf_max_score.html" title="ConfMaxScore is the sub-class of Confidence that computes a confidence estimation for the predicted c...">ConfMaxScore</a> is the sub-class of <a class="el" href="../../da/d7d/classgurls_1_1_confidence.html" title="Confidence is the class that computes a confidence score for the predicted labels.">Confidence</a> that computes a confidence estimation for the predicted class (i.e.  <a href="../../de/ded/classgurls_1_1_conf_max_score.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc9/classgurls_1_1_functor.html">Functor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d29/classgurls_1_1g_exception.html" title="gException is the class designed to deal with exceptions in Gurls++ package.">gException</a> is the class designed to deal with exceptions in Gurls++ package.  <a href="../../d1/d29/classgurls_1_1g_exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html" title="gMat2D implements a matrix of generic size">gMat2D</a> implements a matrix of generic size  <a href="../../d1/d9e/classgurls_1_1g_mat2_d.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6d/classgurls_1_1_g_p_r_wrapper.html">GPRWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d6d/classgurls_1_1_g_p_r_wrapper.html" title="GPRWrapper is the sub-class of GurlsWrapper that implements ...">GPRWrapper</a> is the sub-class of <a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html" title="GurlsWrapper is the base class for all gurls++ wrappers.">GurlsWrapper</a> that implements ...  <a href="../../d1/d6d/classgurls_1_1_g_p_r_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dbe/classgurls_1_1_g_u_r_l_s.html">GURLS</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/dbe/classgurls_1_1_g_u_r_l_s.html" title="GURLS is the class that implements a GURLS process.">GURLS</a> is the class that implements a <a class="el" href="../../d4/dbe/classgurls_1_1_g_u_r_l_s.html" title="GURLS is the class that implements a GURLS process.">GURLS</a> process.  <a href="../../d4/dbe/classgurls_1_1_g_u_r_l_s.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcc/classgurls_1_1_gurls_option.html">GurlsOption</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/dcc/classgurls_1_1_gurls_option.html" title="GurlsOption is an abstraction of a generic `option&#39;, which is widely used within the GURLS++ package ...">GurlsOption</a> is an abstraction of a generic `option', which is widely used within the GURLS++ package to store either numeric parameters necessary to configure specific algorigms or sequences of strings holding the names of the specific procedures that have to be performed.  <a href="../../d5/dcc/classgurls_1_1_gurls_option.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html">GurlsOptionsList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html" title="GurlsOptionsList is an option containing a list of options mapped by name.">GurlsOptionsList</a> is an option containing a list of options mapped by name.  <a href="../../dc/d34/classgurls_1_1_gurls_options_list.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html">GurlsWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html" title="GurlsWrapper is the base class for all gurls++ wrappers.">GurlsWrapper</a> is the base class for all gurls++ wrappers.  <a href="../../d5/d55/classgurls_1_1_gurls_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/d32/classgurls_1_1g_vec.html" title="gVec implements a vector of generic length">gVec</a> implements a vector of generic length  <a href="../../df/d32/classgurls_1_1g_vec.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d35/classgurls_1_1_i_chol_wrapper.html">ICholWrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0c/classgurls_1_1_kernel.html">Kernel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d0c/classgurls_1_1_kernel.html" title="Kernel is the class that computes the kernel matrix.">Kernel</a> is the class that computes the kernel matrix.  <a href="../../dc/d0c/classgurls_1_1_kernel.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classgurls_1_1_kernel_chisquared.html">KernelChisquared</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d82/classgurls_1_1_kernel_chisquared.html" title="KernelChisquared is the sub-class of Kernel that builds the kernel matrix for a chi-squared model...">KernelChisquared</a> is the sub-class of <a class="el" href="../../dc/d0c/classgurls_1_1_kernel.html" title="Kernel is the class that computes the kernel matrix.">Kernel</a> that builds the kernel matrix for a chi-squared model.  <a href="../../dc/d82/classgurls_1_1_kernel_chisquared.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d84/classgurls_1_1_kernel_linear.html">KernelLinear</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/d84/classgurls_1_1_kernel_linear.html" title="KernelLinear is the sub-class of Kernel that builds the kernel matrix for a linear model...">KernelLinear</a> is the sub-class of <a class="el" href="../../dc/d0c/classgurls_1_1_kernel.html" title="Kernel is the class that computes the kernel matrix.">Kernel</a> that builds the kernel matrix for a linear model.  <a href="../../d8/d84/classgurls_1_1_kernel_linear.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d97/classgurls_1_1_kernel_r_b_f.html">KernelRBF</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d97/classgurls_1_1_kernel_r_b_f.html" title="KernelRBF is the sub-class of Kernel that builds the Gaussian kernel matrix.">KernelRBF</a> is the sub-class of <a class="el" href="../../dc/d0c/classgurls_1_1_kernel.html" title="Kernel is the class that computes the kernel matrix.">Kernel</a> that builds the Gaussian kernel matrix.  <a href="../../d0/d97/classgurls_1_1_kernel_r_b_f.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5c/classgurls_1_1_kernel_r_l_s_wrapper.html">KernelRLSWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d5c/classgurls_1_1_kernel_r_l_s_wrapper.html" title="KernelRLSWrapper is the sub-class of GurlsWrapper that implements Regularized Least Squares with a po...">KernelRLSWrapper</a> is the sub-class of <a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html" title="GurlsWrapper is the base class for all gurls++ wrappers.">GurlsWrapper</a> that implements Regularized Least Squares with a possibly non-linear model by resorting to kernel methods.  <a href="../../da/d5c/classgurls_1_1_kernel_r_l_s_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db4/classgurls_1_1_kernel_wrapper.html">KernelWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/db4/classgurls_1_1_kernel_wrapper.html" title="KernelWrapper is the base class for all gurls++ wrappers.">KernelWrapper</a> is the base class for all gurls++ wrappers.  <a href="../../d1/db4/classgurls_1_1_kernel_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db4/classgurls_1_1_lt_compare.html">LtCompare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary class performing floating point comparison used for std routines.  <a href="../../d0/db4/classgurls_1_1_lt_compare.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de1/classgurls_1_1_max.html">Max</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest element in a vector <code>v</code> of lenght <code>n</code>.  <a href="../../dd/de1/classgurls_1_1_max.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de4/classgurls_1_1_mean.html">Mean</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean value of a vector <code>v</code> of lenght <code>n</code>.  <a href="../../d2/de4/classgurls_1_1_mean.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc0/classgurls_1_1_median.html">Median</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the median value of a vector <code>v</code> of lenght <code>n</code>.  <a href="../../d2/dc0/classgurls_1_1_median.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d6c/classgurls_1_1_min.html">Min</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest element in a vector <code>v</code> of lenght <code>n</code>.  <a href="../../d4/d6c/classgurls_1_1_min.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d56/classgurls_1_1_norm.html">Norm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/d56/classgurls_1_1_norm.html" title="Norm is a class that spherifies the data.">Norm</a> is a class that spherifies the data.  <a href="../../d9/d56/classgurls_1_1_norm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d42/classgurls_1_1_norm_l2.html">NormL2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../db/d42/classgurls_1_1_norm_l2.html" title="NormL2 is the sub-class of Norm that spheriphies the data according to the l2 norm.">NormL2</a> is the sub-class of <a class="el" href="../../d9/d56/classgurls_1_1_norm.html" title="Norm is a class that spherifies the data.">Norm</a> that spheriphies the data according to the l2 norm.  <a href="../../db/d42/classgurls_1_1_norm_l2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d98/classgurls_1_1_norm_test_z_score.html">NormTestZScore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../db/d98/classgurls_1_1_norm_test_z_score.html" title="NormTestZScore is the sub-class of Norm that spheriphies the data according to the statistics cmopute...">NormTestZScore</a> is the sub-class of <a class="el" href="../../d9/d56/classgurls_1_1_norm.html" title="Norm is a class that spherifies the data.">Norm</a> that spheriphies the data according to the statistics cmoputed on the training set.  <a href="../../db/d98/classgurls_1_1_norm_test_z_score.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dec/classgurls_1_1_norm_z_score.html">NormZScore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/dec/classgurls_1_1_norm_z_score.html" title="NormZScore is the sub-class of Norm that centers and rescales the input data matrix X...">NormZScore</a> is the sub-class of <a class="el" href="../../d9/d56/classgurls_1_1_norm.html" title="Norm is a class that spherifies the data.">Norm</a> that centers and rescales the input data matrix X.  <a href="../../d5/dec/classgurls_1_1_norm_z_score.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d25/classgurls_1_1_nystrom_wrapper.html">NystromWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d2/d25/classgurls_1_1_nystrom_wrapper.html" title="NystromWrapper is the sub-class of GurlsWrapper that allows to train a possibly non linear model for ...">NystromWrapper</a> is the sub-class of <a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html" title="GurlsWrapper is the base class for all gurls++ wrappers.">GurlsWrapper</a> that allows to train a possibly non linear model for large data sets, for which the complete nxn kernel matrix may not fit into RAM.  <a href="../../d2/d25/classgurls_1_1_nystrom_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d90/classgurls_1_1_opt_array.html">OptArray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optarray is an option containing an indexed array of options.  <a href="../../da/d90/classgurls_1_1_opt_array.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d4b/classgurls_1_1_opt_function.html">OptFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/d4b/classgurls_1_1_opt_function.html" title="OptFunction is an option representing a pointer to a generic function T (*function)(T* ...">OptFunction</a> is an option representing a pointer to a generic function T (*function)(T* , int) operating over an array of floating point numbers.  <a href="../../d8/d4b/classgurls_1_1_opt_function.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html">Optimizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> is a class that implements a Regularized Least Square algorithm.  <a href="../../d6/ddf/classgurls_1_1_optimizer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d63/classgurls_1_1_opt_matrix.html">OptMatrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/d63/classgurls_1_1_opt_matrix.html" title="OptMatrix is an option containing a matrix.">OptMatrix</a> is an option containing a matrix.  <a href="../../de/d63/classgurls_1_1_opt_matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html">OptMatrixBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html" title="OptMatrixBase is the base class for all options containing matrices.">OptMatrixBase</a> is the base class for all options containing matrices.  <a href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classgurls_1_1_opt_number.html">OptNumber</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/d58/classgurls_1_1_opt_number.html" title="OptNumber is an option containing a double precision floating point number.">OptNumber</a> is an option containing a double precision floating point number.  <a href="../../d9/d58/classgurls_1_1_opt_number.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dda/classgurls_1_1_opt_number_list.html">OptNumberList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/dda/classgurls_1_1_opt_number_list.html" title="OptNumberList is an option containing a list of double precision floating point numbers.">OptNumberList</a> is an option containing a list of double precision floating point numbers.  <a href="../../df/dda/classgurls_1_1_opt_number_list.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d52/classgurls_1_1_opt_process.html">OptProcess</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../db/d52/classgurls_1_1_opt_process.html" title="OptProcess is an option containing a sequence of actions that form a Gurls process.">OptProcess</a> is an option containing a sequence of actions that form a Gurls process.  <a href="../../db/d52/classgurls_1_1_opt_process.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d48/classgurls_1_1_opt_string.html">OptString</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d48/classgurls_1_1_opt_string.html" title="OptString is an option containing a generic string.">OptString</a> is an option containing a generic string.  <a href="../../d0/d48/classgurls_1_1_opt_string.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da3/classgurls_1_1_opt_string_list.html">OptStringList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d7/da3/classgurls_1_1_opt_string_list.html" title="OptStringList is an option containing a list of strings.">OptStringList</a> is an option containing a list of strings.  <a href="../../d7/da3/classgurls_1_1_opt_string_list.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d25/classgurls_1_1_opt_task_sequence.html">OptTaskSequence</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d25/classgurls_1_1_opt_task_sequence.html" title="OptTaskSequence is an option containing a sequence of task that forms a pipeline.">OptTaskSequence</a> is an option containing a sequence of task that forms a pipeline.  <a href="../../dc/d25/classgurls_1_1_opt_task_sequence.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dae/classgurls_1_1_param_sel_calibrate_s_g_d.html">ParamSelCalibrateSGD</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ParamselCalibrateSGD is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements parameter selection for pegasos.  <a href="../../d6/dae/classgurls_1_1_param_sel_calibrate_s_g_d.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html">ParamSelection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> is the class that implements parameter selection.  <a href="../../d8/d85/classgurls_1_1_param_selection.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de6/classgurls_1_1_param_sel_fix_lambda.html">ParamSelFixLambda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/de6/classgurls_1_1_param_sel_fix_lambda.html" title="ParamSelFixLambda is the sub-class of ParamSelection that sets the regularization parameter to a cons...">ParamSelFixLambda</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that sets the regularization parameter to a constant.  <a href="../../dd/de6/classgurls_1_1_param_sel_fix_lambda.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8a/classgurls_1_1_param_sel_fix_sig_lam.html">ParamSelFixSigLam</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/d8a/classgurls_1_1_param_sel_fix_sig_lam.html" title="ParamSelFixSigLam is the sub-class of ParamSelection that sets the regularization parameters to const...">ParamSelFixSigLam</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that sets the regularization parameters to constants.  <a href="../../dd/d8a/classgurls_1_1_param_sel_fix_sig_lam.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc2/classgurls_1_1_param_sel_ho_dual.html">ParamSelHoDual</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dc2/classgurls_1_1_param_sel_ho_dual.html" title="ParamSelHoDual is the subclass of ParamSelection that implements hold-out cross validation with the d...">ParamSelHoDual</a> is the subclass of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements hold-out cross validation with the dual formulation of RLS.  <a href="../../de/dc2/classgurls_1_1_param_sel_ho_dual.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9b/classgurls_1_1_param_sel_ho_dualr.html">ParamSelHoDualr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d9b/classgurls_1_1_param_sel_ho_dualr.html" title="ParamSelHoDualr is the randomized version of ParamSelHoDual.">ParamSelHoDualr</a> is the randomized version of <a class="el" href="../../de/dc2/classgurls_1_1_param_sel_ho_dual.html">ParamSelHoDual</a>.  <a href="../../d0/d9b/classgurls_1_1_param_sel_ho_dualr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d89/classgurls_1_1_param_sel_ho_g_p_regr.html">ParamSelHoGPRegr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d89/classgurls_1_1_param_sel_ho_g_p_regr.html" title="ParamSelHoGPRegr is the sub-class of ParamSelection that implements.">ParamSelHoGPRegr</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements.  <a href="../../d6/d89/classgurls_1_1_param_sel_ho_g_p_regr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0c/classgurls_1_1_param_sel_ho_primal.html">ParamSelHoPrimal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d0c/classgurls_1_1_param_sel_ho_primal.html" title="ParamSelHoPrimal is the subclass of ParamSelection that implements hold-out cross validation with the...">ParamSelHoPrimal</a> is the subclass of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements hold-out cross validation with the primal formulation of RLS.  <a href="../../da/d0c/classgurls_1_1_param_sel_ho_primal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc8/classgurls_1_1_param_sel_ho_primalr.html">ParamSelHoPrimalr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../db/dc8/classgurls_1_1_param_sel_ho_primalr.html" title="ParamSelHoPrimalr is the randomized version of ParamSelHoPrimal.">ParamSelHoPrimalr</a> is the randomized version of <a class="el" href="../../da/d0c/classgurls_1_1_param_sel_ho_primal.html">ParamSelHoPrimal</a>.  <a href="../../db/dc8/classgurls_1_1_param_sel_ho_primalr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de0/classgurls_1_1_param_sel_loocv_dual.html">ParamSelLoocvDual</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/de0/classgurls_1_1_param_sel_loocv_dual.html" title="ParamSelLoocvDual is the sub-class of ParamSelection that implements LOO cross-validation with the du...">ParamSelLoocvDual</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements LOO cross-validation with the dual formulation.  <a href="../../dd/de0/classgurls_1_1_param_sel_loocv_dual.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1d/classgurls_1_1_param_sel_loocv_primal.html">ParamSelLoocvPrimal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/d1d/classgurls_1_1_param_sel_loocv_primal.html" title="ParamSelLoocvPrimal is the sub-class of ParamSelection that implements LOO cross-validation with the ...">ParamSelLoocvPrimal</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements LOO cross-validation with the primal formulation.  <a href="../../d3/d1d/classgurls_1_1_param_sel_loocv_primal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9c/classgurls_1_1_param_sel_loo_g_p_regr.html">ParamSelLooGPRegr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d9c/classgurls_1_1_param_sel_loo_g_p_regr.html" title="ParamSelLooGPRegr is the sub-class of ParamSelection that implements.">ParamSelLooGPRegr</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements.  <a href="../../da/d9c/classgurls_1_1_param_sel_loo_g_p_regr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3a/classgurls_1_1_param_sel_siglam.html">ParamSelSiglam</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d3a/classgurls_1_1_param_sel_siglam.html" title="ParamSelSiglam is the sub-class of ParamSelection that implements LOO cross-validation with the dual ...">ParamSelSiglam</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements LOO cross-validation with the dual formulation for a rbf kernel.  <a href="../../d6/d3a/classgurls_1_1_param_sel_siglam.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de3/classgurls_1_1_param_sel_siglam_ho.html">ParamSelSiglamHo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d3a/classgurls_1_1_param_sel_siglam.html" title="ParamSelSiglam is the sub-class of ParamSelection that implements LOO cross-validation with the dual ...">ParamSelSiglam</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements hold-out cross validation with the dual formulation for a rbf kernel.  <a href="../../dc/de3/classgurls_1_1_param_sel_siglam_ho.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/classgurls_1_1_param_sel_siglam_ho_g_p_regr.html">ParamSelSiglamHoGPRegr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/de1/classgurls_1_1_param_sel_siglam_ho_g_p_regr.html" title="ParamSelSiglamHoGPRegr is the sub-class of ParamSelection that implements.">ParamSelSiglamHoGPRegr</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements.  <a href="../../d1/de1/classgurls_1_1_param_sel_siglam_ho_g_p_regr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d75/classgurls_1_1_param_sel_siglam_loo_g_p_regr.html">ParamSelSiglamLooGPRegr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d75/classgurls_1_1_param_sel_siglam_loo_g_p_regr.html" title="ParamSelSiglamLooGPRegr is the sub-class of ParamSelection that implements leave-one-ot parameter sel...">ParamSelSiglamLooGPRegr</a> is the sub-class of <a class="el" href="../../d8/d85/classgurls_1_1_param_selection.html" title="ParamSelection is the class that implements parameter selection.">ParamSelection</a> that implements leave-one-ot parameter selection for Gaussian process regression.  <a href="../../d0/d75/classgurls_1_1_param_sel_siglam_loo_g_p_regr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc8/classgurls_1_1_perf_macro_avg.html">PerfMacroAvg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/dc8/classgurls_1_1_perf_macro_avg.html" title="PerfMacroAvg is the sub-class of Performance that evaluates prediction accuracy.">PerfMacroAvg</a> is the sub-class of <a class="el" href="../../d5/dac/classgurls_1_1_performance.html" title="Performance is the class that evaluates prediction performance.">Performance</a> that evaluates prediction accuracy.  <a href="../../d8/dc8/classgurls_1_1_perf_macro_avg.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dac/classgurls_1_1_performance.html">Performance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/dac/classgurls_1_1_performance.html" title="Performance is the class that evaluates prediction performance.">Performance</a> is the class that evaluates prediction performance.  <a href="../../d5/dac/classgurls_1_1_performance.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbc/classgurls_1_1_perf_prec_rec.html">PerfPrecRec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/dbc/classgurls_1_1_perf_prec_rec.html" title="PerfPrecRec is the sub-class of Performance that evaluates prediction precision.">PerfPrecRec</a> is the sub-class of <a class="el" href="../../d5/dac/classgurls_1_1_performance.html" title="Performance is the class that evaluates prediction performance.">Performance</a> that evaluates prediction precision.  <a href="../../d6/dbc/classgurls_1_1_perf_prec_rec.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc3/classgurls_1_1_perf_rmse.html">PerfRmse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/dc3/classgurls_1_1_perf_rmse.html" title="PerfRmse is the sub-class of Performance that evaluates prediction error.">PerfRmse</a> is the sub-class of <a class="el" href="../../d5/dac/classgurls_1_1_performance.html" title="Performance is the class that evaluates prediction performance.">Performance</a> that evaluates prediction error.  <a href="../../d8/dc3/classgurls_1_1_perf_rmse.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dcd/classgurls_1_1_pred_dual.html">PredDual</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d7/dcd/classgurls_1_1_pred_dual.html" title="PredDual is the sub-class of Prediction that computes the predictions of a linear classifier in the d...">PredDual</a> is the sub-class of <a class="el" href="../../d7/d57/classgurls_1_1_prediction.html" title="Prediction is the class that computes predictions.">Prediction</a> that computes the predictions of a linear classifier in the dual formulation.  <a href="../../d7/dcd/classgurls_1_1_pred_dual.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9e/classgurls_1_1_pred_g_p_regr.html">PredGPRegr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d9e/classgurls_1_1_pred_g_p_regr.html" title="PredGPRegr is the sub-class of Prediction that computes the predictions of GP.">PredGPRegr</a> is the sub-class of <a class="el" href="../../d7/d57/classgurls_1_1_prediction.html" title="Prediction is the class that computes predictions.">Prediction</a> that computes the predictions of GP.  <a href="../../da/d9e/classgurls_1_1_pred_g_p_regr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d57/classgurls_1_1_prediction.html">Prediction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d7/d57/classgurls_1_1_prediction.html" title="Prediction is the class that computes predictions.">Prediction</a> is the class that computes predictions.  <a href="../../d7/d57/classgurls_1_1_prediction.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d99/classgurls_1_1_pred_kernel.html">PredKernel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d99/classgurls_1_1_pred_kernel.html" title="PredKernel is the class that computes the kernel matrix for prediction.">PredKernel</a> is the class that computes the kernel matrix for prediction.  <a href="../../d1/d99/classgurls_1_1_pred_kernel.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd7/classgurls_1_1_pred_kernel_train_test.html">PredKernelTrainTest</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/dd7/classgurls_1_1_pred_kernel_train_test.html" title="PredKernelTrainTest is the sub-class of PredKernel that computes the kernel matrix between training a...">PredKernelTrainTest</a> is the sub-class of <a class="el" href="../../d1/d99/classgurls_1_1_pred_kernel.html" title="PredKernel is the class that computes the kernel matrix for prediction.">PredKernel</a> that computes the kernel matrix between training and test sets.  <a href="../../d3/dd7/classgurls_1_1_pred_kernel_train_test.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d06/classgurls_1_1_pred_primal.html">PredPrimal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/d06/classgurls_1_1_pred_primal.html" title="PredPrimal is the sub-class of Prediction that computes the predictions of a linear classifier in the...">PredPrimal</a> is the sub-class of <a class="el" href="../../d7/d57/classgurls_1_1_prediction.html" title="Prediction is the class that computes predictions.">Prediction</a> that computes the predictions of a linear classifier in the primal formulation.  <a href="../../d8/d06/classgurls_1_1_pred_primal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da4/classgurls_1_1_pred_rand_feats.html">PredRandFeats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d7/da4/classgurls_1_1_pred_rand_feats.html" title="PredRandFeats is the sub-class of Prediction that computes the predictions of the linear classifier s...">PredRandFeats</a> is the sub-class of <a class="el" href="../../d7/d57/classgurls_1_1_prediction.html" title="Prediction is the class that computes predictions.">Prediction</a> that computes the predictions of the linear classifier stored in opt.rls.W, and obtained the Random Features approach proposed in: Ali Rahimi, Ben Recht; Random Features for Large-Scale <a class="el" href="../../dc/d0c/classgurls_1_1_kernel.html" title="Kernel is the class that computes the kernel matrix.">Kernel</a> Machines; in Neural Information Processing Systems (NIPS) 2007.  <a href="../../d7/da4/classgurls_1_1_pred_rand_feats.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de1/classgurls_1_1_random_features_wrapper.html">RandomFeaturesWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d09/classgurls_1_1_r_l_s_wrapper.html" title="RLSWrapper is the sub-class of GurlsWrapper that implements Regularized Least Squares with a linear m...">RLSWrapper</a> is the sub-class of <a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html" title="GurlsWrapper is the base class for all gurls++ wrappers.">GurlsWrapper</a> that implements Regularized Least Squares with a linear model.  <a href="../../db/de1/classgurls_1_1_random_features_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc3/classgurls_1_1_recursive_r_l_s_wrapper.html">RecursiveRLSWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/dc3/classgurls_1_1_recursive_r_l_s_wrapper.html" title="RecursiveRLSWrapper is the sub-class of GurlsWrapper that implements recursive update of the RLS esti...">RecursiveRLSWrapper</a> is the sub-class of <a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html" title="GurlsWrapper is the base class for all gurls++ wrappers.">GurlsWrapper</a> that implements recursive update of the RLS estimator with retraining capability.  <a href="../../d5/dc3/classgurls_1_1_recursive_r_l_s_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d00/classgurls_1_1_r_l_s_auto.html">RLSAuto</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d00/classgurls_1_1_r_l_s_auto.html" title="RLSAuto is the sub-class of Optimizer that implements automatic selection of primal/dual procedure...">RLSAuto</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements automatic selection of primal/dual procedure.  <a href="../../d5/d00/classgurls_1_1_r_l_s_auto.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d15/classgurls_1_1_r_l_s_dual.html">RLSDual</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/d15/classgurls_1_1_r_l_s_dual.html" title="RLSDual is the sub-class of Optimizer that implements RLS with the dual formulation.">RLSDual</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements RLS with the dual formulation.  <a href="../../d3/d15/classgurls_1_1_r_l_s_dual.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3f/classgurls_1_1_r_l_s_dualr.html">RLSDualr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/d3f/classgurls_1_1_r_l_s_dualr.html" title="RLSDualr is the sub-class of Optimizer that implements RLS with the dual formulation, using a randomized version of SVD.">RLSDualr</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements RLS with the dual formulation, using a randomized version of SVD.  <a href="../../d9/d3f/classgurls_1_1_r_l_s_dualr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db3/classgurls_1_1_r_l_s_g_p_regr.html">RLSGPRegr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/db3/classgurls_1_1_r_l_s_g_p_regr.html" title="RLSGPRegr is the sub-class of Optimizer that implements GP inference.">RLSGPRegr</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements GP inference.  <a href="../../d4/db3/classgurls_1_1_r_l_s_g_p_regr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7d/classgurls_1_1_r_l_s_pegasos.html">RLSPegasos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/d7d/classgurls_1_1_r_l_s_pegasos.html" title="RLSPegasos is the sub-class of Optimizer that implements the Pegaosos algorithm.">RLSPegasos</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements the Pegaosos algorithm.  <a href="../../df/d7d/classgurls_1_1_r_l_s_pegasos.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbd/classgurls_1_1_r_l_s_primal.html">RLSPrimal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/dbd/classgurls_1_1_r_l_s_primal.html" title="RLSPrimal is the sub-class of Optimizer that implements RLS with the primal formulation.">RLSPrimal</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements RLS with the primal formulation.  <a href="../../d6/dbd/classgurls_1_1_r_l_s_primal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df5/classgurls_1_1_r_l_s_primalr.html">RLSPrimalr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/df5/classgurls_1_1_r_l_s_primalr.html" title="RLSPrimalr is the sub-class of Optimizer that implements RLS with the primal formulation, using a randomized version of SVD.">RLSPrimalr</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements RLS with the primal formulation, using a randomized version of SVD.  <a href="../../d0/df5/classgurls_1_1_r_l_s_primalr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8f/classgurls_1_1_r_l_s_primal_rec_init.html">RLSPrimalRecInit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d2/d8f/classgurls_1_1_r_l_s_primal_rec_init.html" title="RLSPrimalRecInit is the sub-class of Optimizer that implements RLS with the primal formulation...">RLSPrimalRecInit</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements RLS with the primal formulation.  <a href="../../d2/d8f/classgurls_1_1_r_l_s_primal_rec_init.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dad/classgurls_1_1_r_l_s_primal_rec_update.html">RLSPrimalRecUpdate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/dad/classgurls_1_1_r_l_s_primal_rec_update.html" title="RLSPrimalRecUpdate is the sub-class of Optimizer that implements RLS with the primal formulation...">RLSPrimalRecUpdate</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that implements RLS with the primal formulation.  <a href="../../d6/dad/classgurls_1_1_r_l_s_primal_rec_update.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd6/classgurls_1_1_r_l_s_rand_feats.html">RLSRandFeats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/dd6/classgurls_1_1_r_l_s_rand_feats.html" title="RLSRandFeats is the sub-class of Optimizer that computes a classifier for the primal formulation of R...">RLSRandFeats</a> is the sub-class of <a class="el" href="../../d6/ddf/classgurls_1_1_optimizer.html" title="Optimizer is a class that implements a Regularized Least Square algorithm.">Optimizer</a> that computes a classifier for the primal formulation of RLS using the Random Features approach proposed in: Ali Rahimi, Ben Recht; Random Features for Large-Scale <a class="el" href="../../dc/d0c/classgurls_1_1_kernel.html" title="Kernel is the class that computes the kernel matrix.">Kernel</a> Machines; in Neural Information Processing Systems (NIPS) 2007.  <a href="../../d4/dd6/classgurls_1_1_r_l_s_rand_feats.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d09/classgurls_1_1_r_l_s_wrapper.html">RLSWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d09/classgurls_1_1_r_l_s_wrapper.html" title="RLSWrapper is the sub-class of GurlsWrapper that implements Regularized Least Squares with a linear m...">RLSWrapper</a> is the sub-class of <a class="el" href="../../d5/d55/classgurls_1_1_gurls_wrapper.html" title="GurlsWrapper is the base class for all gurls++ wrappers.">GurlsWrapper</a> that implements Regularized Least Squares with a linear model.  <a href="../../d0/d09/classgurls_1_1_r_l_s_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d41/classgurls_1_1_split.html">Split</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d7/d41/classgurls_1_1_split.html" title="Split is the class that splits data into pair(s) of training and test samples.">Split</a> is the class that splits data into pair(s) of training and test samples.  <a href="../../d7/d41/classgurls_1_1_split.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d75/classgurls_1_1_split_ho.html">SplitHo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitHoMulti is the sub-class of <a class="el" href="../../d7/d41/classgurls_1_1_split.html" title="Split is the class that splits data into pair(s) of training and test samples.">Split</a> that splits data into one or more pairs of training and test samples.  <a href="../../da/d75/classgurls_1_1_split_ho.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a3e7a144c59b79cc681105e939e6c5771">CBLAS_DIAG</a> { <b>CblasNonUnit</b> = 5, 
<b>CblasUnit</b> = 6
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal options (unit, non unit) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ab5c7287e6f0f0083b89564297bdf493c">CBLAS_ORDER</a> { <b>CblasRowMajor</b> = 9, 
<b>CblasColMajor</b> = 10
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix Order (row major or column major) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a65d460224ff1a74c16799b7a2febd70a">CBLAS_SIDE</a> { <b>CblasLeft</b> = 7, 
<b>CblasRight</b> = 8
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Side options (left, right) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> { <b>CblasNoTrans</b> = 0, 
<b>CblasTrans</b> = 1, 
<b>CblasConjTrans</b> = 2
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposition options (no transpose, transpose, conjugate transpose) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a3e3b1abfe9f414a711d30d7c2955d013">CBLAS_UPLO</a> { <b>CblasUpper</b> = 3, 
<b>CblasLower</b> = 4
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper/lower options (upper, lower) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a581b3a6388665e6cdbb47f45c9b43447">InversionAlgorithm</a> { <b>LU</b>, 
<b>GaussJ</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implemented inversion algorithms. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a48a64fe4489faef6c626e2c132495b89">OptTypes</a> { <br/>
&#160;&#160;<b>GenericOption</b>, 
<b>StringOption</b>, 
<b>NumberOption</b>, 
<b>StringListOption</b>, 
<br/>
&#160;&#160;<b>NumberListOption</b>, 
<b>FunctionOption</b>, 
<b>MatrixOption</b>, 
<b>VectorOption</b>, 
<br/>
&#160;&#160;<b>OptListOption</b>, 
<b>TaskSequenceOption</b>, 
<b>TaskIDOption</b>, 
<b>OptArrayOption</b>, 
<br/>
&#160;&#160;<b>ProcessOption</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration containing all implemented Option types. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ae7290ab4b6cd018d525178cf2f740fba">argmin</a> (const T *A, unsigned long *result, const int A_rows, const int A_cols, const int res_length)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Coputes the smallest elements along the rows of a matrix.  <a href="#ae7290ab4b6cd018d525178cf2f740fba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a82ee9c80ec97ed26a84b7d311a2cef76"></a><!-- doxytag: member="gurls::axpy" ref="a82ee9c80ec97ed26a84b7d311a2cef76" args="(const int N, const T alpha, const T *X, const int incX, T *Y, const int incY)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76">axpy</a> (const int N, const T alpha, const T *X, const int incX, T *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *AXPY routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a93392e818a249bdc64e3e1b391847948"></a><!-- doxytag: member="gurls::axpy" ref="a93392e818a249bdc64e3e1b391847948" args="(const int N, const float alpha, const float *X, const int incX, float *Y, const int incY)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a93392e818a249bdc64e3e1b391847948">axpy</a> (const int N, const float alpha, const float *X, const int incX, float *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of axpy for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2de64ae5dbab4cc0415429c1d4a8456"></a><!-- doxytag: member="gurls::axpy" ref="ab2de64ae5dbab4cc0415429c1d4a8456" args="(const int N, const double alpha, const double *X, const int incX, double *Y, const int incY)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ab2de64ae5dbab4cc0415429c1d4a8456">axpy</a> (const int N, const double alpha, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of axpy for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a900d1f0777bb90f8817d31eb67af4460">binOperation</a> (const T *A, const T *B, T *result, const int len, T(*op)(T, T))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an element by element binary operation <img class="formulaInl" alt="$op$" src="../../form_43.png"/> over two vectors ( <img class="formulaInl" alt="$result = A op B$" src="../../form_44.png"/>)  <a href="#a900d1f0777bb90f8817d31eb67af4460"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aba10db703ce209fe176c801b878b135f"></a><!-- doxytag: member="gurls::cholesky" ref="aba10db703ce209fe176c801b878b135f" args="(const gMat2D&lt; T &gt; &amp;A, gMat2D&lt; T &gt; &amp;L, bool upper=true)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aba10db703ce209fe176c801b878b135f">cholesky</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;L, bool upper=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Cholesky factorization of a symmetric, positive definite matrix using the LAPACK routine SPOTRF. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a22152d974dcfd59f248d29db71e4ac28"></a><!-- doxytag: member="gurls::cholesky" ref="a22152d974dcfd59f248d29db71e4ac28" args="(const gMat2D&lt; float &gt; &amp;A, gMat2D&lt; float &gt; &amp;L, bool upper)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a22152d974dcfd59f248d29db71e4ac28">cholesky</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;L, bool upper)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of cholesky for float matrices. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aee7209646b99e3b22a01ac7b99672443">cholesky</a> (const T *matrix, const int rows, const int cols, T *result, bool upper=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Cholesky factorization of a symmetric, positive definite matrix using the LAPACK routine SPOTRF.  <a href="#aee7209646b99e3b22a01ac7b99672443"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#acdb75103dd22dfa78d15facde1ab4264">clearLowerTriangular</a> (T *matrix, int rows, int cols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeroes on the lower triangle of a matrix.  <a href="#acdb75103dd22dfa78d15facde1ab4264"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a95ababd787822755f1471be0f292f388">compare</a> (const T *vector1, const T *vector2, const int size, bool(*pred)(T, T))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares element by element two vectors using a binary predicate, and returns a vector where each element is:  <a href="#a95ababd787822755f1471be0f292f388"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#af451b4a61520b4d079bf1362cd62617e">compare</a> (const T *vector, const T thr, const int size, bool(*pred)(T, T))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares each element of a vector with a threshold using a binary predicate and returns a vector where each element is:  <a href="#af451b4a61520b4d079bf1362cd62617e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded">copy</a> (T *dst, const T *src, const int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies element form one vector to another one.  <a href="#acf8c56c7e1dddb56e5b6b65fcb817ded"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aecc83576a108dcd0cbab3e4956212a9a"></a><!-- doxytag: member="gurls::copy" ref="aecc83576a108dcd0cbab3e4956212a9a" args="(float *dst, const float *src, const int size)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aecc83576a108dcd0cbab3e4956212a9a">copy</a> (float *dst, const float *src, const int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of copy for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ba49c145d274c4f2d7f424ff50c1fab"></a><!-- doxytag: member="gurls::copy" ref="a8ba49c145d274c4f2d7f424ff50c1fab" args="(double *dst, const double *src, const int size)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a8ba49c145d274c4f2d7f424ff50c1fab">copy</a> (double *dst, const double *src, const int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of copy for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2e02d5bd7802f23c7fc5d223d2759631">copy</a> (T *dst, const T *src, const int size, const int dstIncr, const int srcIncr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies element form one vector to another one.  <a href="#a2e02d5bd7802f23c7fc5d223d2759631"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab454d5e33dafced9298ce1b58addc4c6"></a><!-- doxytag: member="gurls::copy" ref="ab454d5e33dafced9298ce1b58addc4c6" args="(float *dst, const float *src, const int size, const int dstIncr, const int srcIncr)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ab454d5e33dafced9298ce1b58addc4c6">copy</a> (float *dst, const float *src, const int size, const int dstIncr, const int srcIncr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of copy for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b170100fd0b364cb865aca0af137277"></a><!-- doxytag: member="gurls::copy" ref="a0b170100fd0b364cb865aca0af137277" args="(double *dst, const double *src, const int size, const int dstIncr, const int srcIncr)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a0b170100fd0b364cb865aca0af137277">copy</a> (double *dst, const double *src, const int size, const int dstIncr, const int srcIncr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of copy for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a136f025f497da2678751fbdd97db463e">copy_submatrix</a> (T *dst, const T *src, const int src_Rows, const int sizeRows, const int sizeCols, unsigned long *indices_rows, unsigned long *indices_cols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a submatrix from an input matrix.  <a href="#a136f025f497da2678751fbdd97db463e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ad606e8b3fbcbadf7bbe942cb16df301a">copyLocations</a> (const unsigned long *locs, const T *src, const int locs_len, const int src_len, T *result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a subvector of an input vector, containing elements of the input vector whose index is contained into an indices vector.  <a href="#ad606e8b3fbcbadf7bbe942cb16df301a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0db7c7ea4f4c93e0d46a959f8e0c76a1"></a><!-- doxytag: member="gurls::copyOptMatrix" ref="a0db7c7ea4f4c93e0d46a959f8e0c76a1" args="(const GurlsOption *toCopy)" -->
template&lt;class MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcc/classgurls_1_1_gurls_option.html">GurlsOption</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyOptMatrix</b> (const <a class="el" href="../../d5/dcc/classgurls_1_1_gurls_option.html">GurlsOption</a> *toCopy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a3286e76a0f264d9cbed8e534fce536c8">diag</a> (T *vector, const int len, T *result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared matrix initialized in the diagonal with values from a vector.  <a href="#a3286e76a0f264d9cbed8e534fce536c8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a40bfc3247c329bd81a818af3383c42c5">distance</a> (const T *A, const T *B, const int rows, const int A_cols, const int B_cols, T *D)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to build the kernel matrix; it computes the matrix of the squared euclidean distance between each column of A and each colum of B.  <a href="#a40bfc3247c329bd81a818af3383c42c5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a506923827bb6ab78e9944facc9afcf13">distance_transposed</a> (const T *A, const T *B, const int cols, const int A_rows, const int B_rows, T *D)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to build the kernel matrix; it computes the matrix of the squared euclidean distance between each row of A and each row of B.  <a href="#a506923827bb6ab78e9944facc9afcf13"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2f5abe81f955fe01b9c78e369a9f1264">distance_transposed_vm</a> (const T *A, const T *B, const int cols, const int B_rows, T *D, const int size, const int incrA=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to build the kernel matrix; it computes the matrix of the squared euclidean distance between a vector A and each row of B.  <a href="#a2f5abe81f955fe01b9c78e369a9f1264"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac21e7810d76da1d8374506562d4bc1fe"></a><!-- doxytag: member="gurls::div" ref="ac21e7810d76da1d8374506562d4bc1fe" args="(T a, T b)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac21e7810d76da1d8374506562d4bc1fe">div</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of two scalars. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a94c9856b6194ac9febd793563c4ac93b"></a><!-- doxytag: member="gurls::dot" ref="a94c9856b6194ac9febd793563c4ac93b" args="(const gVec&lt; float &gt; &amp;x, const gVec&lt; float &gt; &amp;y)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a94c9856b6194ac9febd793563c4ac93b">dot</a> (const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;x, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for float vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a890d491c04c0840044f8c44fad613407"></a><!-- doxytag: member="gurls::dot" ref="a890d491c04c0840044f8c44fad613407" args="(const gVec&lt; double &gt; &amp;x, const gVec&lt; double &gt; &amp;y)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a890d491c04c0840044f8c44fad613407">dot</a> (const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; double &gt; &amp;x, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; double &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for float vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#afaec98de689dfb205e909e39158b4bf3">dot</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;B, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the standard GEMM routine from Level3 BLAS General Matrix-Matrix multiplication of two single/double precision real matrices A and B (the corresponding Matlab code is: C = A*B;).  <a href="#afaec98de689dfb205e909e39158b4bf3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac92c7138ecf5189e1ea35166c29a3f78"></a><!-- doxytag: member="gurls::dot" ref="ac92c7138ecf5189e1ea35166c29a3f78" args="(const gMat2D&lt; float &gt; &amp;A, const gMat2D&lt; float &gt; &amp;B, gMat2D&lt; float &gt; &amp;C)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac92c7138ecf5189e1ea35166c29a3f78">dot</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;B, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for float matrices. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f47b50b7b9a1b985181888eaeead53f"></a><!-- doxytag: member="gurls::dot" ref="a3f47b50b7b9a1b985181888eaeead53f" args="(const int N, const T *X, const int incX, const T *Y, const int incY)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f">dot</a> (const int N, const T *X, const int incX, const T *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *DOT routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#acf47db31be50bae13494a8b266524900">dot</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;x, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the standard DOT routine from Level 1 BLAS General Matrix-Vector multiplication of a single/double precision matrix A with a vector x (the corresponding Matlab code is y = A*x;).  <a href="#acf47db31be50bae13494a8b266524900"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7b064c5865dc4c72cb1d151fc4974a2a"></a><!-- doxytag: member="gurls::dot" ref="a7b064c5865dc4c72cb1d151fc4974a2a" args="(const gMat2D&lt; double &gt; &amp;A, const gMat2D&lt; double &gt; &amp;B, gMat2D&lt; double &gt; &amp;C)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a7b064c5865dc4c72cb1d151fc4974a2a">dot</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; double &gt; &amp;A, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; double &gt; &amp;B, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; double &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for float matrices. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="acb81480624c3f480e3300bd780d3f339"></a><!-- doxytag: member="gurls::dot" ref="acb81480624c3f480e3300bd780d3f339" args="(const gVec&lt; T &gt; &amp;x, const gVec&lt; T &gt; &amp;y)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#acb81480624c3f480e3300bd780d3f339">dot</a> (const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;x, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the standard scalar product between vectors General routine from Level1 BLAS: n &lt;-- x^T * y General Vector-Vector multiplication for single/double precision real data. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a78bf0600ef72818ca76d61eee41847f0"></a><!-- doxytag: member="gurls::dot" ref="a78bf0600ef72818ca76d61eee41847f0" args="(const gMat2D&lt; float &gt; &amp;A, const gVec&lt; float &gt; &amp;x, gVec&lt; float &gt; &amp;y)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a78bf0600ef72818ca76d61eee41847f0">dot</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;x, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af6b99751c681473639f52321e7305d4c"></a><!-- doxytag: member="gurls::dot" ref="af6b99751c681473639f52321e7305d4c" args="(const int N, const float *X, const int incX, const float *Y, const int incY)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#af6b99751c681473639f52321e7305d4c">dot</a> (const int N, const float *X, const int incX, const float *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a94bb39764574aa441d6732dcb5e1a1a2"></a><!-- doxytag: member="gurls::dot" ref="a94bb39764574aa441d6732dcb5e1a1a2" args="(const int N, const double *X, const int incX, const double *Y, const int incY)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a94bb39764574aa441d6732dcb5e1a1a2">dot</a> (const int N, const double *X, const int incX, const double *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9c28d599e620aced3ae3b290858714f"></a><!-- doxytag: member="gurls::dot" ref="ac9c28d599e620aced3ae3b290858714f" args="(const gMat2D&lt; double &gt; &amp;A, const gVec&lt; double &gt; &amp;x, gVec&lt; double &gt; &amp;y)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac9c28d599e620aced3ae3b290858714f">dot</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; double &gt; &amp;A, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; double &gt; &amp;x, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; double &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of dot for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a6ecd2e114188dc4199f38da6eebb99dc">dot</a> (const T *A, const T *B, T *C, int A_rows, int A_cols, int B_rows, int B_cols, int C_rows, int C_cols, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransB, const <a class="el" href="../../db/d4e/namespacegurls.html#ab5c7287e6f0f0083b89564297bdf493c">CBLAS_ORDER</a> Order)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">General Matrix-Matrix multiplication of two single/double precision real matrices A and B.  <a href="#a6ecd2e114188dc4199f38da6eebb99dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c023c0c601cc7362a356efe68139fae"></a><!-- doxytag: member="gurls::eig" ref="a3c023c0c601cc7362a356efe68139fae" args="(const gMat2D&lt; T &gt; &amp;A, gMat2D&lt; T &gt; &amp;V, gVec&lt; T &gt; &amp;Wr, gVec&lt; T &gt; &amp;Wi)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a3c023c0c601cc7362a356efe68139fae">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;V, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;Wr, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;Wi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the computation of the eigenvalues of A using the LAPACK routine SGEEV with default computation of the right eigenvectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a052d337d9de464cf17d8196bdc6e434e"></a><!-- doxytag: member="gurls::eig" ref="a052d337d9de464cf17d8196bdc6e434e" args="(const gMat2D&lt; T &gt; &amp;A, gMat2D&lt; T &gt; &amp;V, gVec&lt; T &gt; &amp;W)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a052d337d9de464cf17d8196bdc6e434e">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;V, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;W)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the computation of the eigenvalues of A using the LAPACK routine SGEEV with default computation of the right eigenvectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e59d4a5e409ee4abef297d9191f11a4"></a><!-- doxytag: member="gurls::eig" ref="a0e59d4a5e409ee4abef297d9191f11a4" args="(const gMat2D&lt; T &gt; &amp;A, gVec&lt; T &gt; &amp;Wr, gVec&lt; T &gt; &amp;Wi)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a0e59d4a5e409ee4abef297d9191f11a4">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;Wr, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;Wi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the computation of the eigenvalues of A. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afa9cb43602a585bcf7924ddd548afc10"></a><!-- doxytag: member="gurls::eig" ref="afa9cb43602a585bcf7924ddd548afc10" args="(const gMat2D&lt; T &gt; &amp;A, gVec&lt; T &gt; &amp;W)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#afa9cb43602a585bcf7924ddd548afc10">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;W)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the computation of the eigenvalues of A. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4884d761d2b86e7f8d666c93cf498294"></a><!-- doxytag: member="gurls::eig" ref="a4884d761d2b86e7f8d666c93cf498294" args="(const gMat2D&lt; float &gt; &amp;A, gMat2D&lt; float &gt; &amp;V, gVec&lt; float &gt; &amp;Wr, gVec&lt; float &gt; &amp;Wi)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a4884d761d2b86e7f8d666c93cf498294">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;V, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;Wr, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;Wi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of eig for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a74087e15c9d84efc304bda432e25fc1a"></a><!-- doxytag: member="gurls::eig" ref="a74087e15c9d84efc304bda432e25fc1a" args="(const gMat2D&lt; float &gt; &amp;A, gMat2D&lt; float &gt; &amp;V, gVec&lt; float &gt; &amp;W)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a74087e15c9d84efc304bda432e25fc1a">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;V, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;W)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of eig for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a335972bee5c08c6c24035703bedb028d"></a><!-- doxytag: member="gurls::eig" ref="a335972bee5c08c6c24035703bedb028d" args="(const gMat2D&lt; float &gt; &amp;A, gVec&lt; float &gt; &amp;Wr, gVec&lt; float &gt; &amp;Wi)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a335972bee5c08c6c24035703bedb028d">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;Wr, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;Wi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of eig for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a717ee82b8ecd84ddac560588a417396b"></a><!-- doxytag: member="gurls::eig" ref="a717ee82b8ecd84ddac560588a417396b" args="(const gMat2D&lt; float &gt; &amp;A, gVec&lt; float &gt; &amp;W)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a717ee82b8ecd84ddac560588a417396b">eig</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;W)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of eig for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aea6911142d7b74fcb892d620e3d4e836">eig_sm</a> (T *A, T *L, int A_rows_cols)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues/eigenvectors of a squared and symmetric input matrix.  <a href="#aea6911142d7b74fcb892d620e3d4e836"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a043f387ab664c3ac5b96aed7b7f748aa"></a><!-- doxytag: member="gurls::eq" ref="a043f387ab664c3ac5b96aed7b7f748aa" args="(T val1, T val2)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa">eq</a> (T val1, T val2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Equals" operator between two scalars <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a9ad5586bb3bc80449b34f14f64c580c1">eq</a> (float val1, float val2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Equals" operator between two scalars, specialized for float values  <a href="#a9ad5586bb3bc80449b34f14f64c580c1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#afd1e987bffaa4b1abad16342258bf76a">eq</a> (double val1, double val2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Equals" operator between two scalars, specialized for double values  <a href="#afd1e987bffaa4b1abad16342258bf76a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aeeb634750e29bb441a65403a58753507">eucl_dist</a> (const T *A, const T *B, const int len, T *work)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Euclidean distance between two vectors.  <a href="#aeeb634750e29bb441a65403a58753507"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5cff575cf62967c55e41b876158cb116"></a><!-- doxytag: member="gurls::Exception_Functionality_Not_Implemented" ref="ga5cff575cf62967c55e41b876158cb116" args="(Exception_Incipit+&quot;An attempt to use a functionality that is not implemented yet occurred.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga5cff575cf62967c55e41b876158cb116">Exception_Functionality_Not_Implemented</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;An attempt to use a functionality that is not implemented yet occurred.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to use a non implemented funcionality. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga969b41bacd919e98e2ac70c55ae90690"></a><!-- doxytag: member="gurls::Exception_Gurls_Inconsistent_Processes_Number" ref="ga969b41bacd919e98e2ac70c55ae90690" args="(Exception_Incipit+&quot;The number of elements in the list of processes/tasks is not consistent.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga969b41bacd919e98e2ac70c55ae90690">Exception_Gurls_Inconsistent_Processes_Number</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;The number of elements in the list of processes/tasks is not consistent.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when the number of gurls processes and gurls tasks are different. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ef06853567bb2ca11299cf629e442eb"></a><!-- doxytag: member="gurls::Exception_Gurls_Invalid_ProcessID" ref="ga2ef06853567bb2ca11299cf629e442eb" args="(Exception_Incipit+&quot;Invalid process ID.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga2ef06853567bb2ca11299cf629e442eb">Exception_Gurls_Invalid_ProcessID</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;Invalid process ID.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when the ID of a process is not found into the gurls process list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad52b41b606b19b5230b17dcaf36b3581"></a><!-- doxytag: member="gurls::Exception_Illegal_Argument_Value" ref="gad52b41b606b19b5230b17dcaf36b3581" args="(Exception_Incipit+&quot;The value of the input variable is not allowed.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#gad52b41b606b19b5230b17dcaf36b3581">Exception_Illegal_Argument_Value</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;The value of the input variable is not allowed.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when an input parameter has an invalid value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf3e993e23eca9e06729d5a7f688a6d1"></a><!-- doxytag: member="gurls::Exception_Illegal_Dynamic_Cast" ref="gacf3e993e23eca9e06729d5a7f688a6d1" args="(Exception_Incipit+&quot;An illegal dynamic cast occured.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#gacf3e993e23eca9e06729d5a7f688a6d1">Exception_Illegal_Dynamic_Cast</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;An illegal dynamic cast occured.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when failing a cast. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae31531ea47ba4e6b6b4f3400a8b1f9be"></a><!-- doxytag: member="gurls::Exception_Incipit" ref="gae31531ea47ba4e6b6b4f3400a8b1f9be" args="(&quot;ERROR! &quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a> (&quot;ERROR! &quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String prefix for all exception messages. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga958853e7664e12a917823fc14b27cbe2"></a><!-- doxytag: member="gurls::Exception_Inconsistent_Size" ref="ga958853e7664e12a917823fc14b27cbe2" args="(Exception_Incipit+&quot;An attempt to combine arrays with inconsistent dimensions occurred.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga958853e7664e12a917823fc14b27cbe2">Exception_Inconsistent_Size</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;An attempt to combine arrays with inconsistent dimensions occurred.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when two arrays have inconsistent dimensions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa753dbdd0384a9d49abd116b9852c651"></a><!-- doxytag: member="gurls::Exception_Index_Out_of_Bound" ref="gaa753dbdd0384a9d49abd116b9852c651" args="(Exception_Incipit+&quot;Index exceeds matrix dimensions.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#gaa753dbdd0384a9d49abd116b9852c651">Exception_Index_Out_of_Bound</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;Index exceeds matrix dimensions.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to access an a vector or matrix with a too large index. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga60adc8928ed4aaf71ceb0938a57f8ffe"></a><!-- doxytag: member="gurls::Exception_Invalid_Reshape_Arguments" ref="ga60adc8928ed4aaf71ceb0938a57f8ffe" args="(Exception_Incipit+&quot;To RESHAPE the number of elements must not change.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga60adc8928ed4aaf71ceb0938a57f8ffe">Exception_Invalid_Reshape_Arguments</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;To RESHAPE the number of elements must not change.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to reshape a matrix changing the number of elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f0864257c80a9753a5b8ae19244bac8"></a><!-- doxytag: member="gurls::Exception_Invalid_TaskSequence" ref="ga8f0864257c80a9753a5b8ae19244bac8" args="(Exception_Incipit+&quot;Invalid task name specification.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga8f0864257c80a9753a5b8ae19244bac8">Exception_Invalid_TaskSequence</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;Invalid task name specification.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to execute an unknown task. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27a6e87e7f8a21247d190115e70abfe0"></a><!-- doxytag: member="gurls::Exception_Logical_Operator" ref="ga27a6e87e7f8a21247d190115e70abfe0" args="(Exception_Incipit+&quot;An unknown logical comparison has been required.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga27a6e87e7f8a21247d190115e70abfe0">Exception_Logical_Operator</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;An unknown logical comparison has been required.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to use an undefined logical operator for comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0290bd6a5e030d72699b646e387f45fe"></a><!-- doxytag: member="gurls::Exception_Parameter_Already_Definied" ref="ga0290bd6a5e030d72699b646e387f45fe" args="(Exception_Incipit+&quot;The parameter has been already defined.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga0290bd6a5e030d72699b646e387f45fe">Exception_Parameter_Already_Definied</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;The parameter has been already defined.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when an options' parameter has been already defined. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73d524f712ebbbeff78033969fc22f80"></a><!-- doxytag: member="gurls::Exception_Parameter_Not_Definied_Yet" ref="ga73d524f712ebbbeff78033969fc22f80" args="(Exception_Incipit+&quot;The requested parameter has not been defined yet.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga73d524f712ebbbeff78033969fc22f80">Exception_Parameter_Not_Definied_Yet</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;The requested parameter has not been defined yet.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when an options' parameter has not been defined yet. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd9f76faa1e908bdc3fe3cdd86ad3d38"></a><!-- doxytag: member="gurls::Exception_Required_Parameter_Missing" ref="gadd9f76faa1e908bdc3fe3cdd86ad3d38" args="(Exception_Incipit+&quot;One of the parameters required to run the algorithm is missing.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#gadd9f76faa1e908bdc3fe3cdd86ad3d38">Exception_Required_Parameter_Missing</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;One of the parameters required to run the algorithm is missing.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when a required parameter for an algorithm is missing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac74b63354114d9abe665f0401ac192f2"></a><!-- doxytag: member="gurls::Exception_Square_Matrix_Required" ref="gac74b63354114d9abe665f0401ac192f2" args="(Exception_Incipit+&quot;An attempt to use a general matrix instead of the required square matrix occurred.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#gac74b63354114d9abe665f0401ac192f2">Exception_Square_Matrix_Required</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;An attempt to use a general matrix instead of the required square matrix occurred.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to use a non squared matrix where a squared one is required. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58a9ef296e084d3fb5b1e97a8453dd25"></a><!-- doxytag: member="gurls::Exception_Unknown_Function" ref="ga58a9ef296e084d3fb5b1e97a8453dd25" args="(Exception_Incipit+&quot;Unknown function.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga58a9ef296e084d3fb5b1e97a8453dd25">Exception_Unknown_Function</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;Unknown function.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to execute an unknown function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e097332c612047e6c03da01ea8c9e94"></a><!-- doxytag: member="gurls::Exception_Unknown_Option" ref="ga3e097332c612047e6c03da01ea8c9e94" args="(Exception_Incipit+&quot;An unknown option has been used.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga3e097332c612047e6c03da01ea8c9e94">Exception_Unknown_Option</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;An unknown option has been used.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to access a non-existent option. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga646ac1cef6a6fc3d7e57595ceb01fbd2"></a><!-- doxytag: member="gurls::Exception_Unsupported_MatrixType" ref="ga646ac1cef6a6fc3d7e57595ceb01fbd2" args="(Exception_Incipit+&quot;Matrix type actually unsupported.&quot;)" -->
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#ga646ac1cef6a6fc3d7e57595ceb01fbd2">Exception_Unsupported_MatrixType</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;Matrix type actually unsupported.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when trying to build a matrix with an unsupported element type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group___exceptions.html#gae614edc485bffb1fe5fbce48e7078fba">Exception_Wrong_Memory_Access</a> (<a class="el" href="../../d1/dc9/group___exceptions.html#gae31531ea47ba4e6b6b4f3400a8b1f9be">Exception_Incipit</a>+&quot;An attempt to acces a non-existent memory location occurred.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Message displayed when a method tryes to modify an array that is not the owner of its data.  <a href="../../d1/dc9/group___exceptions.html#gae614edc485bffb1fe5fbce48e7078fba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a4d9ac407d614639d9fe776fca148585b">exp</a> (T *v, const int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">In place computation of the exponential for each element of a vector.  <a href="#a4d9ac407d614639d9fe776fca148585b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c4fd96e77654eb7a8fa8e8d26d1a720"></a><!-- doxytag: member="gurls::gelss" ref="a9c4fd96e77654eb7a8fa8e8d26d1a720" args="(int *m, int *n, int *nrhs, T *a, int *lda, T *b, int *ldb, T *s, T *rcond, int *rank, T *work, int *lwork, int *info)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a9c4fd96e77654eb7a8fa8e8d26d1a720">gelss</a> (int *m, int *n, int *nrhs, T *a, int *lda, T *b, int *ldb, T *s, T *rcond, int *rank, T *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call LAPACK *GELSS routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a72a4296c98ec9d4999e46296d5988833"></a><!-- doxytag: member="gurls::gelss" ref="a72a4296c98ec9d4999e46296d5988833" args="(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *s, float *rcond, int *rank, float *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a72a4296c98ec9d4999e46296d5988833">gelss</a> (int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *s, float *rcond, int *rank, float *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gelss for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a48e3bb5783bfd83c47f8206fb4639e17"></a><!-- doxytag: member="gurls::gelss" ref="a48e3bb5783bfd83c47f8206fb4639e17" args="(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *s, double *rcond, int *rank, double *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a48e3bb5783bfd83c47f8206fb4639e17">gelss</a> (int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *s, double *rcond, int *rank, double *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gelss for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ae2e8587a69c8f2d7d15e68b272b4b1"></a><!-- doxytag: member="gurls::gemm" ref="a4ae2e8587a69c8f2d7d15e68b272b4b1" args="(const CBLAS_TRANSPOSE TransA, const CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const float alpha, const float *A, const int lda, const float *B, const int ldb, const float beta, float *C, const int ldc)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a4ae2e8587a69c8f2d7d15e68b272b4b1">gemm</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransB, const int M, const int N, const int K, const float alpha, const float *A, const int lda, const float *B, const int ldb, const float beta, float *C, const int ldc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gemm for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae2a654adc22d3ce050bc0920185877d6"></a><!-- doxytag: member="gurls::gemm" ref="ae2a654adc22d3ce050bc0920185877d6" args="(const CBLAS_TRANSPOSE TransA, const CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const double alpha, const double *A, const int lda, const double *B, const int ldb, const double beta, double *C, const int ldc)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ae2a654adc22d3ce050bc0920185877d6">gemm</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransB, const int M, const int N, const int K, const double alpha, const double *A, const int lda, const double *B, const int ldb, const double beta, double *C, const int ldc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gemm for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1269a74e7f7e3d1ca200b6d8d3d0709f"></a><!-- doxytag: member="gurls::gemm" ref="a1269a74e7f7e3d1ca200b6d8d3d0709f" args="(const CBLAS_TRANSPOSE TransA, const CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const T alpha, const T *A, const int lda, const T *B, const int ldb, const T beta, T *C, const int ldc)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a1269a74e7f7e3d1ca200b6d8d3d0709f">gemm</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransB, const int M, const int N, const int K, const T alpha, const T *A, const int lda, const T *B, const int ldb, const T beta, T *C, const int ldc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *GEMM routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a140be15552f45a4f51b167b60cd636b4"></a><!-- doxytag: member="gurls::gemv" ref="a140be15552f45a4f51b167b60cd636b4" args="(const CBLAS_TRANSPOSE TransA, const int M, const int N, const T alpha, const T *A, const int lda, const T *X, const int incX, const T beta, T *Y, const int incY)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a140be15552f45a4f51b167b60cd636b4">gemv</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const int M, const int N, const T alpha, const T *A, const int lda, const T *X, const int incX, const T beta, T *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *GEMV routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="affab79a3dc91af85e1cad66ade344659"></a><!-- doxytag: member="gurls::gemv" ref="affab79a3dc91af85e1cad66ade344659" args="(const CBLAS_TRANSPOSE TransA, const int M, const int N, const float alpha, const float *A, const int lda, const float *X, const int incX, const float beta, float *Y, const int incY)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#affab79a3dc91af85e1cad66ade344659">gemv</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const int M, const int N, const float alpha, const float *A, const int lda, const float *X, const int incX, const float beta, float *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gemv for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a09c29df40236f54ffac755200519392d"></a><!-- doxytag: member="gurls::gemv" ref="a09c29df40236f54ffac755200519392d" args="(const CBLAS_TRANSPOSE TransA, const int M, const int N, const double alpha, const double *A, const int lda, const double *X, const int incX, const double beta, double *Y, const int incY)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a09c29df40236f54ffac755200519392d">gemv</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const int M, const int N, const double alpha, const double *A, const int lda, const double *X, const int incX, const double beta, double *Y, const int incY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gemv for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0aa5f2111625115a7f28b7c408b531b"></a><!-- doxytag: member="gurls::geqp3" ref="aa0aa5f2111625115a7f28b7c408b531b" args="(int *m, int *n, T *A, int *lda, int *jpvt, T *tau, T *work, int *lwork, int *info)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aa0aa5f2111625115a7f28b7c408b531b">geqp3</a> (int *m, int *n, T *A, int *lda, int *jpvt, T *tau, T *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call LAPACK *GEQP3 routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a67acd60419463068a14dd8ba70c77690"></a><!-- doxytag: member="gurls::geqp3" ref="a67acd60419463068a14dd8ba70c77690" args="(int *m, int *n, float *A, int *lda, int *jpvt, float *tau, float *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a67acd60419463068a14dd8ba70c77690">geqp3</a> (int *m, int *n, float *A, int *lda, int *jpvt, float *tau, float *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of geqp3 for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0dc35ba7fdee7bd3db3c8eeebc63ab17"></a><!-- doxytag: member="gurls::geqp3" ref="a0dc35ba7fdee7bd3db3c8eeebc63ab17" args="(int *m, int *n, double *A, int *lda, int *jpvt, double *tau, double *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a0dc35ba7fdee7bd3db3c8eeebc63ab17">geqp3</a> (int *m, int *n, double *A, int *lda, int *jpvt, double *tau, double *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of geqp3 for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aab6cd9a9688f9d62ee51cf92fb4dac5d"></a><!-- doxytag: member="gurls::gesvd_" ref="aab6cd9a9688f9d62ee51cf92fb4dac5d" args="(char *jobu, char *jobvt, int *m, int *n, T *a, int *lda, T *s, T *u, int *ldu, T *vt, int *ldvt, T *work, int *lwork, int *info)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aab6cd9a9688f9d62ee51cf92fb4dac5d">gesvd_</a> (char *jobu, char *jobvt, int *m, int *n, T *a, int *lda, T *s, T *u, int *ldu, T *vt, int *ldvt, T *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *GESVD routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aefc54cff58ae59ff3463455be85cc1b8"></a><!-- doxytag: member="gurls::gesvd_" ref="aefc54cff58ae59ff3463455be85cc1b8" args="(char *jobu, char *jobvt, int *m, int *n, float *a, int *lda, float *s, float *u, int *ldu, float *vt, int *ldvt, float *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aefc54cff58ae59ff3463455be85cc1b8">gesvd_</a> (char *jobu, char *jobvt, int *m, int *n, float *a, int *lda, float *s, float *u, int *ldu, float *vt, int *ldvt, float *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gesvd_ for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a51445435d73fd84d801854a834a9fc58"></a><!-- doxytag: member="gurls::gesvd_" ref="a51445435d73fd84d801854a834a9fc58" args="(char *jobu, char *jobvt, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a51445435d73fd84d801854a834a9fc58">gesvd_</a> (char *jobu, char *jobvt, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of gesvd_ for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f26bfcffcde4bba16f38f91eed41298"></a><!-- doxytag: member="gurls::getMatrixCellType" ref="a7f26bfcffcde4bba16f38f91eed41298" args="()" -->
template&lt;class Matrix &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html#a6af16d68562e1aaa340c96bc43403efc">OptMatrixBase::MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getMatrixCellType</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3de9ce5673c3faa328a976d68c66ae96"></a><!-- doxytag: member="gurls::getMatrixCellType&lt; const gMat2D&lt; double &gt; &gt;" ref="a3de9ce5673c3faa328a976d68c66ae96" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT <br class="typebreak"/>
<a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html#a6af16d68562e1aaa340c96bc43403efc">OptMatrixBase::MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getMatrixCellType&lt; const gMat2D&lt; double &gt; &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aedf4bd1621c81550e2e56e68e1442ebf"></a><!-- doxytag: member="gurls::getMatrixCellType&lt; const gMat2D&lt; float &gt; &gt;" ref="aedf4bd1621c81550e2e56e68e1442ebf" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT <br class="typebreak"/>
<a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html#a6af16d68562e1aaa340c96bc43403efc">OptMatrixBase::MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getMatrixCellType&lt; const gMat2D&lt; float &gt; &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac71509b1b784fd4734d31dec15d0e52b"></a><!-- doxytag: member="gurls::getMatrixCellType&lt; gMat2D&lt; double &gt; &gt;" ref="ac71509b1b784fd4734d31dec15d0e52b" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT <br class="typebreak"/>
<a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html#a6af16d68562e1aaa340c96bc43403efc">OptMatrixBase::MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getMatrixCellType&lt; gMat2D&lt; double &gt; &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a713d4189c798aa54d973d368418619ba"></a><!-- doxytag: member="gurls::getMatrixCellType&lt; gMat2D&lt; float &gt; &gt;" ref="a713d4189c798aa54d973d368418619ba" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT <br class="typebreak"/>
<a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html#a6af16d68562e1aaa340c96bc43403efc">OptMatrixBase::MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getMatrixCellType&lt; gMat2D&lt; float &gt; &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a76773df3c7da5ff23fd4a31a83c639ce"></a><!-- doxytag: member="gurls::getMatrixCellType&lt; gMat2D&lt; unsigned long &gt; &gt;" ref="a76773df3c7da5ff23fd4a31a83c639ce" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT <br class="typebreak"/>
<a class="el" href="../../d3/dfe/classgurls_1_1_opt_matrix_base.html#a6af16d68562e1aaa340c96bc43403efc">OptMatrixBase::MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getMatrixCellType&lt; gMat2D&lt; unsigned long &gt; &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547">getRow</a> (const T *M, const int rows, const int cols, const int row_index, T *row)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector containing a copy of a row of an input matrix.  <a href="#ad7448a55e9fec1102f1716192fe11547"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad8033740d34139ac1e186b93f3da1ab5"></a><!-- doxytag: member="gurls::GInverseDiagonal" ref="ad8033740d34139ac1e186b93f3da1ab5" args="(const T *Q, const T *L, const T *lambda, T *Z, const int Q_rows, const int Q_cols, const int L_length, const int lambda_length)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GInverseDiagonal</b> (const T *Q, const T *L, const T *lambda, T *Z, const int Q_rows, const int Q_cols, const int L_length, const int lambda_length)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b05dad32d28b0406bf8cff158e7d457"></a><!-- doxytag: member="gurls::GInverseDiagonal" ref="a5b05dad32d28b0406bf8cff158e7d457" args="(const T *Q, const T *L, const T *lambda, T *Z, const int Q_rows, const int Q_cols, const int L_length, const int lambda_length, T *work)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GInverseDiagonal</b> (const T *Q, const T *L, const T *lambda, T *Z, const int Q_rows, const int Q_cols, const int L_length, const int lambda_length, T *work)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c4b44477c465507bbe9ec446b40a71f"></a><!-- doxytag: member="gurls::gt" ref="a4c4b44477c465507bbe9ec446b40a71f" args="(T a, T b)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f">gt</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Greater than" operator between two scalars <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac628e7f04e8532e2e5846dd14f35a916">gt</a> (float a, float b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Greater than" operator between two scalars, specialized for float values  <a href="#ac628e7f04e8532e2e5846dd14f35a916"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a502d376f316213cc2017c2c15e2924b4">gt</a> (double a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Greater than" operator between two scalars, specialized for double values  <a href="#a502d376f316213cc2017c2c15e2924b4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afe47c23bed46af6a16e44d6a74bd7e85"></a><!-- doxytag: member="gurls::gte" ref="afe47c23bed46af6a16e44d6a74bd7e85" args="(T a, T b)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#afe47c23bed46af6a16e44d6a74bd7e85">gte</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Greater than or equals" operator between two scalars <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a8ac8d49555f8c0a752a51f302a2611e0">indicesOfEqualsTo</a> (const T *V, const int len, const T value, unsigned long *ind, int &amp;ind_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector containing the indices of all elements of an input vector that are equals to a given value.  <a href="#a8ac8d49555f8c0a752a51f302a2611e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a4b88bbd60e323172b176e170126583ea">indicesOfMax</a> (const T *A, const int A_rows, const int A_cols, unsigned long *ind, T *work, const int dimension)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indices of the largest elements along different dimensions of a matrix.  <a href="#a4b88bbd60e323172b176e170126583ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aaefdcbd8f4882f2e980cde947d470f54"></a><!-- doxytag: member="gurls::inv" ref="aaefdcbd8f4882f2e980cde947d470f54" args="(const gMat2D&lt; float &gt; &amp;A, gMat2D&lt; float &gt; &amp;Ainv, InversionAlgorithm alg)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aaefdcbd8f4882f2e980cde947d470f54">inv</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;Ainv, <a class="el" href="../../db/d4e/namespacegurls.html#a581b3a6388665e6cdbb47f45c9b43447">InversionAlgorithm</a> alg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of inv for float matrices. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa07000abad8e75e5ea43aa92b9b62447"></a><!-- doxytag: member="gurls::inv" ref="aa07000abad8e75e5ea43aa92b9b62447" args="(const gMat2D&lt; T &gt; &amp;A, gMat2D&lt; T &gt; &amp;Ainv, InversionAlgorithm alg=LU)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aa07000abad8e75e5ea43aa92b9b62447">inv</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;Ainv, <a class="el" href="../../db/d4e/namespacegurls.html#a581b3a6388665e6cdbb47f45c9b43447">InversionAlgorithm</a> alg=LU)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse <img class="formulaInl" alt="$A^-{1}$" src="../../form_42.png"/> of a matrix <img class="formulaInl" alt="$A$" src="../../form_6.png"/>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a68355fb1c541564d3179538285d4673a">lambdaguesses</a> (const T *eigvals, const int len, const int r, const int n, const int nlambda, const T minl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds array of possible values for the regularization parameter, generating a geometric series from the values in EIGVALS Internal function, not to be called from gurls.  <a href="#a68355fb1c541564d3179538285d4673a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a141eeb37a2b25f93bfcde3453641dc8c"></a><!-- doxytag: member="gurls::le" ref="a141eeb37a2b25f93bfcde3453641dc8c" args="(T a, T b)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a141eeb37a2b25f93bfcde3453641dc8c">le</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Less or equal than" operator between two scalars <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3d21517d1d6205fe9b6da238bb7348af"></a><!-- doxytag: member="gurls::linspace" ref="a3d21517d1d6205fe9b6da238bb7348af" args="(T a, T b, unsigned long n, T *res)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a3d21517d1d6205fe9b6da238bb7348af">linspace</a> (T a, T b, unsigned long n, T *res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a row vector of n points linearly spaced between and including a and b. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a57330e9148465f7dad58b80361e4b510"></a><!-- doxytag: member="gurls::lt" ref="a57330e9148465f7dad58b80361e4b510" args="(T a, T b)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a57330e9148465f7dad58b80361e4b510">lt</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Less than" operator between two scalars <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2881d6d5ce35586ea88b6b485f6afa3a">lt</a> (float a, float b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Less than" operator between two scalars, specialized for float values  <a href="#a2881d6d5ce35586ea88b6b485f6afa3a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a710b4faef3dc85d1e07dd6bdfbe78b30">lt</a> (double a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Less than" operator between two scalars, specialized for double values  <a href="#a710b4faef3dc85d1e07dd6bdfbe78b30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2aea606f269de6a897bcfda5a11897b6"></a><!-- doxytag: member="gurls::lu" ref="a2aea606f269de6a897bcfda5a11897b6" args="(gMat2D&lt; T &gt; &amp;A)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2aea606f269de6a897bcfda5a11897b6">lu</a> (<a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the LU decomposition usig LAPACK routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a73da67aa7117e56d52b5a88759cf3d78">lu</a> (<a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; int &gt; &amp;pv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges, using LAPACK routines.  <a href="#a73da67aa7117e56d52b5a88759cf3d78"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a97d0945c7e119434e9941fd2af1636ed"></a><!-- doxytag: member="gurls::lu" ref="a97d0945c7e119434e9941fd2af1636ed" args="(gMat2D&lt; float &gt; &amp;A, gVec&lt; int &gt; &amp;pv)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a97d0945c7e119434e9941fd2af1636ed">lu</a> (<a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; int &gt; &amp;pv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of lu for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1cfdeee30ddb12b831944630f918cf4"></a><!-- doxytag: member="gurls::lu" ref="ae1cfdeee30ddb12b831944630f918cf4" args="(gMat2D&lt; float &gt; &amp;A)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ae1cfdeee30ddb12b831944630f918cf4">lu</a> (<a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of lu for float matrices. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a32e6ab8c84d4bee2f94efedc5e8ea53a">maxValues</a> (const T *A, const int A_rows, const int A_cols, T *maxv, T *work, const int dimension)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest elements along different dimensions of a matrix.  <a href="#a32e6ab8c84d4bee2f94efedc5e8ea53a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a85151ab18d29196f25627917c9526088">mean</a> (const T *A, T *result, const int A_rows, const int A_cols, const int res_length)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean values along the rows of a matrix.  <a href="#a85151ab18d29196f25627917c9526088"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aaf1db63a5209152b935c2fbc7b7f8352">median</a> (T *v, const int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the median value of a vector.  <a href="#aaf1db63a5209152b935c2fbc7b7f8352"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac6c7c43939ffdc334083440d0d4b84ea">median</a> (const T *M, const int rows, const int cols, const int dimension, T *res, T *work)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the median values of the elements along different dimensions of a matrix.  <a href="#ac6c7c43939ffdc334083440d0d4b84ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aa4cf57d556e713079f9f556a0951486e">mldivide_squared</a> (const T *A, T *B, const int a_rows, const int a_cols, const int b_rows, const int b_cols, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> transA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left division of squared matrices.  <a href="#aa4cf57d556e713079f9f556a0951486e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6b4396e2c97744191760e762697ae46"></a><!-- doxytag: member="gurls::mul" ref="ac6b4396e2c97744191760e762697ae46" args="(T a, T b)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac6b4396e2c97744191760e762697ae46">mul</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two scalars. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a43a5eeef1874c15e091086b62cfcaebd">mult</a> (const T *A, const T *B, T *result, const int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Element by element multiplication of two vectors.  <a href="#a43a5eeef1874c15e091086b62cfcaebd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af37cded61440c0f4c5e6b121e32f1961"></a><!-- doxytag: member="gurls::norm" ref="af37cded61440c0f4c5e6b121e32f1961" args="(const gVec&lt; T &gt; &amp;x, std::string type=&quot;l2&quot;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#af37cded61440c0f4c5e6b121e32f1961">norm</a> (const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;x, std::string type=&quot;l2&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector norm specified by <em>type</em> parameter. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aede1544769680472b68e7a4c6dffcd37"></a><!-- doxytag: member="gurls::norm" ref="aede1544769680472b68e7a4c6dffcd37" args="(const gMat2D&lt; T &gt; &amp;A, std::string type=&quot;l2&quot;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aede1544769680472b68e7a4c6dffcd37">norm</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, std::string type=&quot;l2&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix norm specified by <em>type</em> parameter. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afc7fa72c121304f29f5a4f6ea6874994"></a><!-- doxytag: member="gurls::nrm2" ref="afc7fa72c121304f29f5a4f6ea6874994" args="(const int N, const T *X, const int incX)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#afc7fa72c121304f29f5a4f6ea6874994">nrm2</a> (const int N, const T *X, const int incX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *NRM2 routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8235c30a1bb018e0e5fcd70b9184018"></a><!-- doxytag: member="gurls::nrm2" ref="ab8235c30a1bb018e0e5fcd70b9184018" args="(const int N, const float *X, const int incX)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ab8235c30a1bb018e0e5fcd70b9184018">nrm2</a> (const int N, const float *X, const int incX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of nrm2 for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a97ab036038ecb33220118ce805cc7f10"></a><!-- doxytag: member="gurls::nrm2" ref="a97ab036038ecb33220118ce805cc7f10" args="(const int N, const double *X, const int incX)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a97ab036038ecb33220118ce805cc7f10">nrm2</a> (const int N, const double *X, const int incX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of nrm2 for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ada30920060e23d395d2b22d153cb12e3"></a><!-- doxytag: member="gurls::operator*" ref="ada30920060e23d395d2b22d153cb12e3" args="(T val, const gVec&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ada30920060e23d395d2b22d153cb12e3">operator*</a> (T val, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the multiplication of a vector by a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1be9268ed0abb9746e1025fe2a86fe01"></a><!-- doxytag: member="gurls::operator*" ref="a1be9268ed0abb9746e1025fe2a86fe01" args="(T val, const gMat2D&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a1be9268ed0abb9746e1025fe2a86fe01">operator*</a> (T val, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the multiplication of a matrix by a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a28ece3ae12c57c9747f565ea856849d9"></a><!-- doxytag: member="gurls::operator+" ref="a28ece3ae12c57c9747f565ea856849d9" args="(T val, const gVec&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a28ece3ae12c57c9747f565ea856849d9">operator+</a> (T val, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the sum between a vector and a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac472918778c976f6a1c70f461b5178ef"></a><!-- doxytag: member="gurls::operator+" ref="ac472918778c976f6a1c70f461b5178ef" args="(T val, const gMat2D&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac472918778c976f6a1c70f461b5178ef">operator+</a> (T val, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the sum between a matrix and a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a09daaf289678f08d4c929052deda6edd"></a><!-- doxytag: member="gurls::operator&#45;" ref="a09daaf289678f08d4c929052deda6edd" args="(T val, const gVec&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a09daaf289678f08d4c929052deda6edd">operator-</a> (T val, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the difference between a vector and a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a827a203489b48410aba93895eb61fde6"></a><!-- doxytag: member="gurls::operator&#45;" ref="a827a203489b48410aba93895eb61fde6" args="(T val, const gMat2D&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a827a203489b48410aba93895eb61fde6">operator-</a> (T val, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the difference between a matrix and a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ada216af26c881e14e0d512fd7e4aa788"></a><!-- doxytag: member="gurls::operator/" ref="ada216af26c881e14e0d512fd7e4aa788" args="(T val, const gMat2D&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ada216af26c881e14e0d512fd7e4aa788">operator/</a> (T val, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the division of a matrix by a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a35803e4fd26a32e35a0cae0f7937c594"></a><!-- doxytag: member="gurls::operator/" ref="a35803e4fd26a32e35a0cae0f7937c594" args="(T val, const gVec&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a35803e4fd26a32e35a0cae0f7937c594">operator/</a> (T val, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the division of a vector by a scalar. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GURLS_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ad21f1808454425473f265494395b6785">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../d5/dcc/classgurls_1_1_gurls_option.html">GurlsOption</a> &amp;opt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="../../d5/dcc/classgurls_1_1_gurls_option.html" title="GurlsOption is an abstraction of a generic `option&#39;, which is widely used within the GURLS++ package ...">GurlsOption</a> to a stream.  <a href="#ad21f1808454425473f265494395b6785"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbb36cc13f8494342fdacde543e41e8e"></a><!-- doxytag: member="gurls::operator&lt;&lt;" ref="adbb36cc13f8494342fdacde543e41e8e" args="(std::ostream &amp;os, const OptArray &amp;opt)" -->
GURLS_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#adbb36cc13f8494342fdacde543e41e8e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/d90/classgurls_1_1_opt_array.html">OptArray</a> &amp;opt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an <a class="el" href="../../da/d90/classgurls_1_1_opt_array.html" title="Optarray is an option containing an indexed array of options.">OptArray</a> to a stream. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a52bd63daa33a34e29ed1b5e5012905c3"></a><!-- doxytag: member="gurls::operator&lt;&lt;" ref="a52bd63daa33a34e29ed1b5e5012905c3" args="(std::ostream &amp;os, const gVec&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a52bd63daa33a34e29ed1b5e5012905c3">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes vector's information and data to a stream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a786f0834db9fa2581770c202ee3656a0"></a><!-- doxytag: member="gurls::operator&lt;&lt;" ref="a786f0834db9fa2581770c202ee3656a0" args="(std::ostream &amp;os, const GurlsOptionsList &amp;opt)" -->
GURLS_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a786f0834db9fa2581770c202ee3656a0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html">GurlsOptionsList</a> &amp;opt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html" title="GurlsOptionsList is an option containing a list of options mapped by name.">GurlsOptionsList</a> to a stream. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6238254b36fc2884748344999a7be1b1"></a><!-- doxytag: member="gurls::operator&lt;&lt;" ref="a6238254b36fc2884748344999a7be1b1" args="(std::ostream &amp;os, const gMat2D&lt; T &gt; &amp;v)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a6238254b36fc2884748344999a7be1b1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes matrix information and data to a stream. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa49db48641a374f0e7d8a3dd421998b8"></a><!-- doxytag: member="gurls::operator==" ref="aa49db48641a374f0e7d8a3dd421998b8" args="(const BaseArray&lt; U &gt; &amp;v, const U &amp;val)" -->
template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aa49db48641a374f0e7d8a3dd421998b8">operator==</a> (const <a class="el" href="../../d9/d8b/classgurls_1_1_base_array.html">BaseArray</a>&lt; U &gt; &amp;v, const U &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements in a vector are equal to a given value. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a36c0da4854aae09c2ad6cce35768fef6"></a><!-- doxytag: member="gurls::operator==" ref="a36c0da4854aae09c2ad6cce35768fef6" args="(const gVec&lt; U &gt; &amp;v, const U &amp;val)" -->
template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a36c0da4854aae09c2ad6cce35768fef6">operator==</a> (const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; U &gt; &amp;v, const U &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements in a vector are equal to a given value. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac37f8063b27b971d09494aaa5a41d1da"></a><!-- doxytag: member="gurls::orgqr" ref="ac37f8063b27b971d09494aaa5a41d1da" args="(int *m, int *n, int *k, T *a, int *lda, T *tau, T *work, int *lwork, int *info)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac37f8063b27b971d09494aaa5a41d1da">orgqr</a> (int *m, int *n, int *k, T *a, int *lda, T *tau, T *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call LAPACK *ORGQR routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5de7ff2128c74dae7d9a09a50a393bab"></a><!-- doxytag: member="gurls::orgqr" ref="a5de7ff2128c74dae7d9a09a50a393bab" args="(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a5de7ff2128c74dae7d9a09a50a393bab">orgqr</a> (int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of orogqr for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e6f1468218b452093535ab8390d518a"></a><!-- doxytag: member="gurls::orgqr" ref="a4e6f1468218b452093535ab8390d518a" args="(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a4e6f1468218b452093535ab8390d518a">orgqr</a> (int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of orgqr for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aae1b80d6308d315bae49f7e8e5c00fd4">pdist</a> (const T *A, const int N, const int P, T *D)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector D containing the Euclidean distances between each pair of observations in the N-by-P data matrix A.  <a href="#aae1b80d6308d315bae49f7e8e5c00fd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a753b9fab2b7733245db71f4d59bcfc9b"></a><!-- doxytag: member="gurls::pinv" ref="a753b9fab2b7733245db71f4d59bcfc9b" args="(const gMat2D&lt; T &gt; &amp;A, gMat2D&lt; T &gt; &amp;Ainv, T RCOND=0)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a753b9fab2b7733245db71f4d59bcfc9b">pinv</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;Ainv, T RCOND=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pseudo-inverse of a non square matrix A. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a462f86faf9d2c90f8871ae7e223eb432"></a><!-- doxytag: member="gurls::pinv" ref="a462f86faf9d2c90f8871ae7e223eb432" args="(const gMat2D&lt; float &gt; &amp;A, gMat2D&lt; float &gt; &amp;Ainv, float RCOND)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a462f86faf9d2c90f8871ae7e223eb432">pinv</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;Ainv, float RCOND)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of pinv for float matrices. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#adfc28aaab9ad9111e413da721438370a">pinv</a> (const T *A, const int rows, const int cols, int &amp;res_rows, int &amp;res_cols, T *RCOND=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pseudo-inverse of a matrix.  <a href="#adfc28aaab9ad9111e413da721438370a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8da7753eb788f84ac8474d39996f541f"></a><!-- doxytag: member="gurls::potrf_" ref="a8da7753eb788f84ac8474d39996f541f" args="(char *UPLO, int *n, T *a, int *lda, int *info)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a8da7753eb788f84ac8474d39996f541f">potrf_</a> (char *UPLO, int *n, T *a, int *lda, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call LAPACK *POTRF routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a39dee0a0ece0c39fa94fc01725eccb9a"></a><!-- doxytag: member="gurls::potrf_" ref="a39dee0a0ece0c39fa94fc01725eccb9a" args="(char *UPLO, int *n, float *a, int *lda, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a39dee0a0ece0c39fa94fc01725eccb9a">potrf_</a> (char *UPLO, int *n, float *a, int *lda, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of potrf_ for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2dd619a2e30c7d5039bd1312395bf361"></a><!-- doxytag: member="gurls::potrf_" ref="a2dd619a2e30c7d5039bd1312395bf361" args="(char *UPLO, int *n, double *a, int *lda, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2dd619a2e30c7d5039bd1312395bf361">potrf_</a> (char *UPLO, int *n, double *a, int *lda, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of potrf_ for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#acb4047b769eb39affe91e125f8ecb6df">precrec_driver</a> (const T *out, const T *<a class="el" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f">gt</a>, const unsigned long N, T *work)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function called by the class PrecisionRecall to evaluate the average precision through precision and recall.  <a href="#acb4047b769eb39affe91e125f8ecb6df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#af8659cac31df668780f9e9b022262526">precrec_driver</a> (const T *out, const T *<a class="el" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f">gt</a>, const unsigned long N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function called by the class PrecisionRecall to evaluate the average precision through precision and recall.  <a href="#af8659cac31df668780f9e9b022262526"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a9a5138062bf688f49c7a6d67ed71b25f">qr_econ</a> (const T *A, int m, int n, T *Q, T *R, int *E)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an economy-size QR decomposition of an input matrix A so that A(:,E) = Q*R.  <a href="#a9a5138062bf688f49c7a6d67ed71b25f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#adf6dc7afcc579ec3a85a1b7e29962c4c">random_svd</a> (const T *A, const unsigned long A_rows, const unsigned long A_cols, T *U, T *S, T *V, unsigned long k=6, unsigned long its=2, unsigned long l=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a nearly optimal rank-<em>k</em> approximation USV' to <em>A</em>, using <em>its</em> full iterations of a block Lanczos method of block size <em>l</em>, started with an n x <em>l</em> random matrix, when <em>A</em> is m x n;.  <a href="#adf6dc7afcc579ec3a85a1b7e29962c4c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a75f6afe3bf7f7be79d66714593f5c7bc"></a><!-- doxytag: member="gurls::randperm" ref="a75f6afe3bf7f7be79d66714593f5c7bc" args="(const unsigned long n, T *seq, bool generate=true, unsigned long start=1)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a75f6afe3bf7f7be79d66714593f5c7bc">randperm</a> (const unsigned long n, T *seq, bool generate=true, unsigned long start=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector containing a random permutation of the values from start to start+n inclusive. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a53b8a878e025a9aecca369bfdd383dcc">rdivide</a> (const T *A, const T *B, T *result, const int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Element by element division of two vectors.  <a href="#a53b8a878e025a9aecca369bfdd383dcc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad699cc67d7f80b2219808f0a5fc90b5d"></a><!-- doxytag: member="gurls::repmat" ref="ad699cc67d7f80b2219808f0a5fc90b5d" args="(const gVec&lt; T &gt; &amp;x, unsigned long n, bool transpose=false)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ad699cc67d7f80b2219808f0a5fc90b5d">repmat</a> (const <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;x, unsigned long n, bool <a class="el" href="../../db/d4e/namespacegurls.html#a6d60c6fa2a1a6336ebf51e9adfbf3d7e">transpose</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicates a vector n times along the columns (or along the rows if transpose==true) If x is a vector of length N, then the output is an N-by-N matrix whose columns (or rows) are copies of x. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a0cd2d49089ac88dd5ccf4b91e3b97bff">rls_eigen</a> (const T *Q, const T *L, const T *Qty, T *C, const T lambda, const int n, const int Q_rows, const int Q_cols, const int L_length, const int Qty_rows, const int Qty_cols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes RLS estimator given the singular value decomposition of the kernel matrix.  <a href="#a0cd2d49089ac88dd5ccf4b91e3b97bff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ab2fc16e3ae966dc22dc6e4ad8ab4ed0d">rls_eigen</a> (const T *Q, const T *L, const T *Qty, T *C, const T lambda, const int n, const int Q_rows, const int Q_cols, const int L_length, const int Qty_rows, const int Qty_cols, T *work)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes RLS estimator given the singular value decomposition of the kernel matrix.  <a href="#ab2fc16e3ae966dc22dc6e4ad8ab4ed0d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html">GurlsOptionsList</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aaf3d4c52d803726cffe2b9ae96fd7e12">rls_pegasos_driver</a> (const T *X, const T *bY, const <a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html">GurlsOptionsList</a> &amp;opt, const int X_rows, const int X_cols, const int bY_rows, const int bY_cols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function called by the class <a class="el" href="../../df/d7d/classgurls_1_1_r_l_s_pegasos.html" title="RLSPegasos is the sub-class of Optimizer that implements the Pegaosos algorithm.">RLSPegasos</a> to implement a single pass for pegasos algorithm, performing the stochastic gradient descent over all training samples once.  <a href="#aaf3d4c52d803726cffe2b9ae96fd7e12"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b01d39c5f186779f83e1b018b2d91e2"></a><!-- doxytag: member="gurls::rls_primal_driver" ref="a9b01d39c5f186779f83e1b018b2d91e2" args="(T *K, const T *Xty, const unsigned long n, const unsigned long d, const unsigned long Yd, const T lambda)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rls_primal_driver</b> (T *K, const T *Xty, const unsigned long n, const unsigned long d, const unsigned long Yd, const T lambda)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a049b19eedddd32d4bd23a8279c83dc6e"></a><!-- doxytag: member="gurls::round" ref="a049b19eedddd32d4bd23a8279c83dc6e" args="(const T value)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a049b19eedddd32d4bd23a8279c83dc6e">round</a> (const T value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds an input value to the nearest integer. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b5a754d6c99cab678e84ca19be7b876"></a><!-- doxytag: member="gurls::rp_apply_real" ref="a6b5a754d6c99cab678e84ca19be7b876" args="(const T *X, const T *W, const unsigned long n, const unsigned long d, const unsigned long D)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rp_apply_real</b> (const T *X, const T *W, const unsigned long n, const unsigned long d, const unsigned long D)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a671674d082fca8e267457737df09e412"></a><!-- doxytag: member="gurls::rp_apply_real" ref="a671674d082fca8e267457737df09e412" args="(const gMat2D&lt; T &gt; &amp;X, const gMat2D&lt; T &gt; &amp;W)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rp_apply_real</b> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;X, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;W)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a554f828da229efada0549f0d3a44805f"></a><!-- doxytag: member="gurls::rp_factorize_large_real" ref="a554f828da229efada0549f0d3a44805f" args="(const gMat2D&lt; T &gt; &amp;X, const gMat2D&lt; T &gt; &amp;y, const unsigned long D, const unsigned long psize, T *XtX, T *Xty)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rp_factorize_large_real</b> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;X, const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;y, const unsigned long D, const unsigned long psize, T *XtX, T *Xty)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ade086a4dfbee1e3776148ba8b658e98b"></a><!-- doxytag: member="gurls::rp_projections" ref="ade086a4dfbee1e3776148ba8b658e98b" args="(const unsigned long d, const unsigned long D)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rp_projections</b> (const unsigned long d, const unsigned long D)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a82615df00122dfb0d589a5a245d612be"></a><!-- doxytag: member="gurls::scal" ref="a82615df00122dfb0d589a5a245d612be" args="(const int N, const T alpha, T *X, const int incX)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a82615df00122dfb0d589a5a245d612be">scal</a> (const int N, const T alpha, T *X, const int incX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *SCAL routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aecb1485e0b101a624372a1c8fbf096b7"></a><!-- doxytag: member="gurls::scal" ref="aecb1485e0b101a624372a1c8fbf096b7" args="(const int N, const float alpha, float *X, const int incX)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aecb1485e0b101a624372a1c8fbf096b7">scal</a> (const int N, const float alpha, float *X, const int incX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of scal for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a78b04e535c29a22044af98d1781d4bbb"></a><!-- doxytag: member="gurls::scal" ref="a78b04e535c29a22044af98d1781d4bbb" args="(const int N, const double alpha, double *X, const int incX)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a78b04e535c29a22044af98d1781d4bbb">scal</a> (const int N, const double alpha, double *X, const int incX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of scal for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2b510185d90e724e1b848aa7fe000612">set</a> (T *buffer, const T value, const int size, const int incr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets elements of a vector to a specified value.  <a href="#a2b510185d90e724e1b848aa7fe000612"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a055f95a43e117399de4db553fe1154e2">set</a> (T *buffer, const T value, const int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of a vector to a specified value.  <a href="#a055f95a43e117399de4db553fe1154e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a194580ce49ef180370dd5612555e1d55"></a><!-- doxytag: member="gurls::set" ref="a194580ce49ef180370dd5612555e1d55" args="(float *buffer, const float value, const int size)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void GURLS_EXPORT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a194580ce49ef180370dd5612555e1d55">set</a> (float *buffer, const float value, const int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of set for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a96bbaff79057c5dd18cab543577f38a8"></a><!-- doxytag: member="gurls::set" ref="a96bbaff79057c5dd18cab543577f38a8" args="(double *buffer, const double value, const int size)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void GURLS_EXPORT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a96bbaff79057c5dd18cab543577f38a8">set</a> (double *buffer, const double value, const int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of set for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aabea5b7e1a752e4ecc60b71b07b0db0d"></a><!-- doxytag: member="gurls::set" ref="aabea5b7e1a752e4ecc60b71b07b0db0d" args="(float *buffer, const float value, const int size, const int incr)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void GURLS_EXPORT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aabea5b7e1a752e4ecc60b71b07b0db0d">set</a> (float *buffer, const float value, const int size, const int incr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of set for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8510c7de065778c3066834e7328169c"></a><!-- doxytag: member="gurls::set" ref="ab8510c7de065778c3066834e7328169c" args="(double *buffer, const double value, const int size, const int incr)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void GURLS_EXPORT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ab8510c7de065778c3066834e7328169c">set</a> (double *buffer, const double value, const int size, const int incr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of set for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a153b5476d7a4deb157db95079469c2cb">setReciprocal</a> (T *matrix, const int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the element-by-element multiplicative inverse of an input matrix.  <a href="#a153b5476d7a4deb157db95079469c2cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a1722b64bc35b5a0a8ed920bd41a182f4">sign</a> (const T *vector, const int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a "signum vector" of the same size as an input vector, where each element is:  <a href="#a1722b64bc35b5a0a8ed920bd41a182f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#abb76e3d861e7dce6464e4f29c1620336">sort</a> (const T *M, const unsigned long rows, const unsigned long cols, bool(*pred)(T, T), T *values, unsigned long *indices)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a matrix along the columns.  <a href="#abb76e3d861e7dce6464e4f29c1620336"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2edac8fc521c5bb7e91c90f1bbe80172">squareform</a> (const T *A, const int N, const int P, T *D, const int d_cols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reformats a distance matrix between upper triangular and square form.  <a href="#a2edac8fc521c5bb7e91c90f1bbe80172"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac18259120405abd399d5dccf5c9735fb">stdDev</a> (const T *X, const int rows, const int cols, T *res, T *work)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a row vector containing the standard deviation of the elements of each column of an input matrix.  <a href="#ac18259120405abd399d5dccf5c9735fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aaed8f970da9e1fc94319ba8579b88986">subMatrixFromColumns</a> (const T *matrix, const int mRows, const int mCols, const unsigned long *colsIndices, const int nIndices, T *submat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a submatrix from an input matrix.  <a href="#aaed8f970da9e1fc94319ba8579b88986"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a4015e8417bc5f4375da5524d7b67338c">subMatrixFromRows</a> (const T *matrix, const int mRows, const int mCols, const unsigned long *rowsIndices, const int nIndices, T *submat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a submatrix from an input matrix.  <a href="#a4015e8417bc5f4375da5524d7b67338c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a77ab8b750db64540cedadd69b6ba433f">sum</a> (const T *A, T *result, const int A_rows, const int A_cols, const int res_length)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums all elements along the rows of a matrix.  <a href="#a77ab8b750db64540cedadd69b6ba433f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a6ad5abc1e6f16da6c801ad8a93dfb731">sum_col</a> (const T *A, T *result, const int A_rows, const int A_cols)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums all elements along the columns of a matrix.  <a href="#a6ad5abc1e6f16da6c801ad8a93dfb731"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2f1802e90fc6d89dcc35bfef3c369250">sumv</a> (const T *V, const int len)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of all elements of a vector.  <a href="#a2f1802e90fc6d89dcc35bfef3c369250"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ac363704394a8b83cc1929f35864064ef">svd</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;U, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; T &gt; &amp;W, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; T &gt; &amp;Vt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the SVD decomposition of a general rectangular matrix: A = U*W*Vt.  <a href="#ac363704394a8b83cc1929f35864064ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d99e62e823ba3350b9d8f2c7d1d6e9f"></a><!-- doxytag: member="gurls::svd" ref="a7d99e62e823ba3350b9d8f2c7d1d6e9f" args="(const gMat2D&lt; float &gt; &amp;A, gMat2D&lt; float &gt; &amp;U, gVec&lt; float &gt; &amp;W, gMat2D&lt; float &gt; &amp;Vt)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a7d99e62e823ba3350b9d8f2c7d1d6e9f">svd</a> (const <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;A, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;U, <a class="el" href="../../df/d32/classgurls_1_1g_vec.html">gVec</a>&lt; float &gt; &amp;W, <a class="el" href="../../d1/d9e/classgurls_1_1g_mat2_d.html">gMat2D</a>&lt; float &gt; &amp;Vt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of svd for float matrices/vectors. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a89bed76dd7920ad067ca0f5548feafdd">svd</a> (const T *A, T *&amp;U, T *&amp;S, T *&amp;Vt, const int A_rows, const int A_cols, int &amp;U_rows, int &amp;U_cols, int &amp;S_len, int &amp;Vt_rows, int &amp;Vt_cols, bool econ=false)  throw (gException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes singular value decomposition of an input matrix A such that A = U*diag(S)*Vt.  <a href="#a89bed76dd7920ad067ca0f5548feafdd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a07ed08cb9d78507e8d2c849d1cce648e"></a><!-- doxytag: member="gurls::swap" ref="a07ed08cb9d78507e8d2c849d1cce648e" args="(int n, T *x, int incx, T *y, int incy)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a07ed08cb9d78507e8d2c849d1cce648e">swap</a> (int n, T *x, int incx, T *y, int incy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *SWAP routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a006445be54f71fa4cb0d5b10b9d2f626"></a><!-- doxytag: member="gurls::swap" ref="a006445be54f71fa4cb0d5b10b9d2f626" args="(int n, float *x, int incx, float *y, int incy)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a006445be54f71fa4cb0d5b10b9d2f626">swap</a> (int n, float *x, int incx, float *y, int incy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of swap for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a10f8f9bd5319436f8f9c5d954dc030ae"></a><!-- doxytag: member="gurls::swap" ref="a10f8f9bd5319436f8f9c5d954dc030ae" args="(int n, double *x, int incx, double *y, int incy)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a10f8f9bd5319436f8f9c5d954dc030ae">swap</a> (int n, double *x, int incx, double *y, int incy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of swap for double buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ec8c883faab27e2907625bf8e7677da"></a><!-- doxytag: member="gurls::syev" ref="a6ec8c883faab27e2907625bf8e7677da" args="(char *jobz, char *uplo, int *n, T *a, int *lda, T *w, T *work, int *lwork, int *info)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a6ec8c883faab27e2907625bf8e7677da">syev</a> (char *jobz, char *uplo, int *n, T *a, int *lda, T *w, T *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call LAPACK *SYEV routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8dcf5e05286bb38993ac273535f45f03"></a><!-- doxytag: member="gurls::syev" ref="a8dcf5e05286bb38993ac273535f45f03" args="(char *jobz, char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a8dcf5e05286bb38993ac273535f45f03">syev</a> (char *jobz, char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of syev for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9dfdf96fc4be20c9bbeed0b5a0e21248"></a><!-- doxytag: member="gurls::syev" ref="a9dfdf96fc4be20c9bbeed0b5a0e21248" args="(char *jobz, char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *info)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a9dfdf96fc4be20c9bbeed0b5a0e21248">syev</a> (char *jobz, char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of syev for double buffers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a2270d88158df11a01a89f70dead4986c">TASKDESC_SEPARATOR</a> (&quot;:&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String used to tokenize task strings (e.g.  <a href="#a2270d88158df11a01a89f70dead4986c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#ade3f4598bd1adbc6b009209aa409635e">test_classifier</a> (T *W, <a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html">GurlsOptionsList</a> &amp;opt, const int rows, const int cols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function called by the rls_pegasos_driver; it evaluate classification accuracy on the test set given in fields Xte and yte of opt.  <a href="#ade3f4598bd1adbc6b009209aa409635e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a6d60c6fa2a1a6336ebf51e9adfbf3d7e">transpose</a> (const T *matrix, const int rows, const int cols, T *transposed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a matrix.  <a href="#a6d60c6fa2a1a6336ebf51e9adfbf3d7e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a736d5bda0bca8dff4586fc1de89eedc9"></a><!-- doxytag: member="gurls::trsm" ref="a736d5bda0bca8dff4586fc1de89eedc9" args="(const CBLAS_SIDE Side, const CBLAS_UPLO Uplo, const CBLAS_TRANSPOSE TransA, const CBLAS_DIAG Diag, const int M, const int N, const T alpha, const T *A, const int lda, T *B, const int ldb)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a736d5bda0bca8dff4586fc1de89eedc9">trsm</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#a65d460224ff1a74c16799b7a2febd70a">CBLAS_SIDE</a> Side, const <a class="el" href="../../db/d4e/namespacegurls.html#a3e3b1abfe9f414a711d30d7c2955d013">CBLAS_UPLO</a> Uplo, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const <a class="el" href="../../db/d4e/namespacegurls.html#a3e7a144c59b79cc681105e939e6c5771">CBLAS_DIAG</a> Diag, const int M, const int N, const T alpha, const T *A, const int lda, T *B, const int ldb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to call BLAS *TRSM routines. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5aaba5d222dfc54fbeed11af7b1175b8"></a><!-- doxytag: member="gurls::trsm" ref="a5aaba5d222dfc54fbeed11af7b1175b8" args="(const CBLAS_SIDE Side, const CBLAS_UPLO Uplo, const CBLAS_TRANSPOSE TransA, const CBLAS_DIAG Diag, const int M, const int N, const float alpha, const float *A, const int lda, float *B, const int ldb)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a5aaba5d222dfc54fbeed11af7b1175b8">trsm</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#a65d460224ff1a74c16799b7a2febd70a">CBLAS_SIDE</a> Side, const <a class="el" href="../../db/d4e/namespacegurls.html#a3e3b1abfe9f414a711d30d7c2955d013">CBLAS_UPLO</a> Uplo, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const <a class="el" href="../../db/d4e/namespacegurls.html#a3e7a144c59b79cc681105e939e6c5771">CBLAS_DIAG</a> Diag, const int M, const int N, const float alpha, const float *A, const int lda, float *B, const int ldb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of trsm for float buffers. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a130348dfd1df52f06b44742b9ee6bd25"></a><!-- doxytag: member="gurls::trsm" ref="a130348dfd1df52f06b44742b9ee6bd25" args="(const CBLAS_SIDE Side, const CBLAS_UPLO Uplo, const CBLAS_TRANSPOSE TransA, const CBLAS_DIAG Diag, const int M, const int N, const double alpha, const double *A, const int lda, double *B, const int ldb)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">GURLS_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a130348dfd1df52f06b44742b9ee6bd25">trsm</a> (const <a class="el" href="../../db/d4e/namespacegurls.html#a65d460224ff1a74c16799b7a2febd70a">CBLAS_SIDE</a> Side, const <a class="el" href="../../db/d4e/namespacegurls.html#a3e3b1abfe9f414a711d30d7c2955d013">CBLAS_UPLO</a> Uplo, const <a class="el" href="../../db/d4e/namespacegurls.html#aac2b1ccde06a9871a52d7eb19d7e3154">CBLAS_TRANSPOSE</a> TransA, const <a class="el" href="../../db/d4e/namespacegurls.html#a3e7a144c59b79cc681105e939e6c5771">CBLAS_DIAG</a> Diag, const int M, const int N, const double alpha, const double *A, const int lda, double *B, const int ldb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of trsm for double buffers. <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf6481f6844f82fc3f44119d2d47158a"></a><!-- doxytag: member="gurls::COLUMNWISE" ref="aaf6481f6844f82fc3f44119d2d47158a" args="" -->
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aaf6481f6844f82fc3f44119d2d47158a">COLUMNWISE</a> = 0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to tell methods to operate on a matrix in column-wise order. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43e8662fd4f3931c97a53a9547bee45c"></a><!-- doxytag: member="gurls::L0norm" ref="a43e8662fd4f3931c97a53a9547bee45c" args="" -->
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a43e8662fd4f3931c97a53a9547bee45c">L0norm</a> = &quot;l0&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String identifying l0-norm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5bf9b9d001587d568e3a297f053f35d"></a><!-- doxytag: member="gurls::L1norm" ref="af5bf9b9d001587d568e3a297f053f35d" args="" -->
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#af5bf9b9d001587d568e3a297f053f35d">L1norm</a> = &quot;l1&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String identifying l1-norm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3725a490ac50d56cabf19833d2255341"></a><!-- doxytag: member="gurls::L2norm" ref="a3725a490ac50d56cabf19833d2255341" args="" -->
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a3725a490ac50d56cabf19833d2255341">L2norm</a> = &quot;l2&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String identifying l2-norm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7d778719a779aebd251350924f63daa"></a><!-- doxytag: member="gurls::LInfnorm" ref="aa7d778719a779aebd251350924f63daa" args="" -->
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#aa7d778719a779aebd251350924f63daa">LInfnorm</a> = &quot;inf&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String identifying infinity-norm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a11d0fc7949708ef68897305433953b8b">MAX_PRINTABLE_SIZE</a> = 200</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum vector size for printing.  <a href="#a11d0fc7949708ef68897305433953b8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7b6295bf9ef68cbae818bb6f0a3cff"></a><!-- doxytag: member="gurls::ROWWISE" ref="a6b7b6295bf9ef68cbae818bb6f0a3cff" args="" -->
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4e/namespacegurls.html#a6b7b6295bf9ef68cbae818bb6f0a3cff">ROWWISE</a> = 1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to tell methods to operate on a matrix in row-wise order. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The namespace gurls comprises all the classes, constants, typedefs, and functions currently available within the library. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae7290ab4b6cd018d525178cf2f740fba"></a><!-- doxytag: member="gurls::argmin" ref="ae7290ab4b6cd018d525178cf2f740fba" args="(const T *A, unsigned long *result, const int A_rows, const int A_cols, const int res_length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#ae7290ab4b6cd018d525178cf2f740fba">gurls::argmin</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>res_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">result</td><td>vecotr of length A_cols containing the smallest elements for each row of the matrix </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">res_length</td><td>results vector length (MUST be == A_cols) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00874">874</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span>(A_cols != res_length)
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#ga958853e7664e12a917823fc14b27cbe2" title="Message displayed when two arrays have inconsistent dimensions.">Exception_Inconsistent_Size</a>);

    <span class="keyword">const</span> T *a_it = A;

    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *r_it = result, *r_end = result+A_cols; r_it != r_end; ++r_it, a_it += A_rows)
        *r_it = (std::min_element(a_it, a_it+A_rows) - a_it);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a900d1f0777bb90f8817d31eb67af4460"></a><!-- doxytag: member="gurls::binOperation" ref="a900d1f0777bb90f8817d31eb67af4460" args="(const T *A, const T *B, T *result, const int len, T(*op)(T, T))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a900d1f0777bb90f8817d31eb67af4460">gurls::binOperation</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(*)(T, T)&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first input vector </td></tr>
    <tr><td class="paramname">B</td><td>second input vector </td></tr>
    <tr><td class="paramname">result</td><td>vector </td></tr>
    <tr><td class="paramname">len</td><td>vectors length </td></tr>
    <tr><td class="paramname">op</td><td>binary operation to perform </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00747">747</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T *a_it = A, *a_end = A+len;
    <span class="keyword">const</span> T *b_it = B;
    T *r_it = result;

    <span class="keywordflow">while</span>(a_it != a_end)
    {
        *r_it = (*op)((*a_it),(*b_it));

        ++a_it;
        ++b_it;
        ++r_it;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aee7209646b99e3b22a01ac7b99672443"></a><!-- doxytag: member="gurls::cholesky" ref="aee7209646b99e3b22a01ac7b99672443" args="(const T *matrix, const int rows, const int cols, T *result, bool upper=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#aba10db703ce209fe176c801b878b135f">gurls::cholesky</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>input matrix </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">upper</td><td>whether to store the upper or the lower triangle of the result matrix </td></tr>
    <tr><td class="paramname">resyult</td><td>Cholesky factorization of the input matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00586">586</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(result, matrix, rows*cols);

    <span class="keywordtype">int</span> LDA = rows;
    <span class="keywordtype">int</span> nc = cols;
    <span class="keywordtype">char</span> UPLO = upper? <span class="charliteral">&#39;U&#39;</span>:<span class="charliteral">&#39;L&#39;</span>;
    <span class="keywordtype">int</span> info;

    <a class="code" href="../../db/d4e/namespacegurls.html#a8da7753eb788f84ac8474d39996f541f" title="Template function to call LAPACK *POTRF routines.">potrf_</a>(&amp;UPLO, &amp;nc, result, &amp;LDA, &amp;info);

    <span class="keywordflow">if</span>(info != 0)
    {
        std::stringstream str;
        str &lt;&lt; <span class="stringliteral">&quot;Cholesky factorization failed, error code &quot;</span> &lt;&lt; info &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> gException(str.str());
    }

    <a class="code" href="../../db/d4e/namespacegurls.html#acdb75103dd22dfa78d15facde1ab4264" title="Zeroes on the lower triangle of a matrix.">clearLowerTriangular</a>(result, rows, cols);
}
</pre></div>
</div>
</div>
<a class="anchor" id="acdb75103dd22dfa78d15facde1ab4264"></a><!-- doxytag: member="gurls::clearLowerTriangular" ref="acdb75103dd22dfa78d15facde1ab4264" args="(T *matrix, int rows, int cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#acdb75103dd22dfa78d15facde1ab4264">gurls::clearLowerTriangular</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>input matrix </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00391">391</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* it = matrix;
    <span class="keyword">const</span> T zero = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.0);

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= cols; ++i)
    {
        <span class="keyword">const</span> <span class="keywordtype">int</span> len = rows-i;

        <span class="keywordflow">if</span>(len &gt; 0)
        {
            it+=i;

            <span class="keyword">set</span>(it, zero, len);

            it+=len;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a95ababd787822755f1471be0f292f388"></a><!-- doxytag: member="gurls::compare" ref="a95ababd787822755f1471be0f292f388" args="(const T *vector1, const T *vector2, const int size, bool(*pred)(T, T))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="../../db/d4e/namespacegurls.html#a95ababd787822755f1471be0f292f388">gurls::compare</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>vector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(T, T)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<ul>
<li>1 if comparison predicate was verified on the pair of elements at the corresponging index</li>
<li>0 if comparison predicate was not verified on the pair of elements at the corresponging index</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector1</td><td>first input vector </td></tr>
    <tr><td class="paramname">vector2</td><td>second input vector </td></tr>
    <tr><td class="paramname">size</td><td>number of elements of the input vectors </td></tr>
    <tr><td class="paramname">pred</td><td>binary predicate used for comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the results vector </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01044">1044</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T* v1_end = vector1+size;

    T* ret = <span class="keyword">new</span> T[size];
    T* r_it = ret;

    <span class="keyword">const</span> T zero = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.0);
    <span class="keyword">const</span> T one = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(1.0);

    <span class="keywordflow">for</span>(<span class="keyword">const</span> T *v1_it = vector1, *v2_it = vector2; v1_it != v1_end; ++v1_it, ++v2_it, ++r_it)
        *r_it = (*pred)(*v1_it, *v2_it)? one: zero;

    <span class="keywordflow">return</span> ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af451b4a61520b4d079bf1362cd62617e"></a><!-- doxytag: member="gurls::compare" ref="af451b4a61520b4d079bf1362cd62617e" args="(const T *vector, const T thr, const int size, bool(*pred)(T, T))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="../../db/d4e/namespacegurls.html#a95ababd787822755f1471be0f292f388">gurls::compare</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(T, T)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<ul>
<li>1 if comparison predicate was verified on the pair (element at the corresponging index, threshold)</li>
<li>0 if comparison predicate was not verified on the pair (element at the corresponging index, threshold)</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>input vector </td></tr>
    <tr><td class="paramname">thr</td><td>threshold </td></tr>
    <tr><td class="paramname">size</td><td>number of elements of the input vector </td></tr>
    <tr><td class="paramname">pred</td><td>binary predicate used for comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the results vector </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01074">1074</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T* v1_end = vector+size;

    T* ret = <span class="keyword">new</span> T[size];
    T* r_it = ret;

    <span class="keyword">const</span> T zero = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.0);
    <span class="keyword">const</span> T one = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(1.0);

    <span class="keywordflow">for</span>(<span class="keyword">const</span> T *v1_it = vector; v1_it != v1_end; ++v1_it, ++r_it)
        *r_it = (*pred)(*v1_it, thr)? one: zero;

    <span class="keywordflow">return</span> ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acf8c56c7e1dddb56e5b6b65fcb817ded"></a><!-- doxytag: member="gurls::copy" ref="acf8c56c7e1dddb56e5b6b65fcb817ded" args="(T *dst, const T *src, const int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded">gurls::copy</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination vector </td></tr>
    <tr><td class="paramname">src</td><td>source vector </td></tr>
    <tr><td class="paramname">size</td><td>vectors length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00266">266</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    memcpy(dst, src, size*<span class="keyword">sizeof</span>(T));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2e02d5bd7802f23c7fc5d223d2759631"></a><!-- doxytag: member="gurls::copy" ref="a2e02d5bd7802f23c7fc5d223d2759631" args="(T *dst, const T *src, const int size, const int dstIncr, const int srcIncr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded">gurls::copy</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dstIncr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>srcIncr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination vector </td></tr>
    <tr><td class="paramname">src</td><td>source vector </td></tr>
    <tr><td class="paramname">size</td><td>number of copies to be performed </td></tr>
    <tr><td class="paramname">dstIncr</td><td>iteration increment on destination buffer </td></tr>
    <tr><td class="paramname">srcIncr</td><td>iteration increment on source buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00293">293</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span>(dstIncr == 1 &amp;&amp; srcIncr == 1)
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(dst, src, size);

    <span class="keywordflow">else</span>
    {
        <span class="keyword">const</span> T* s_it = src;

        <span class="keywordflow">for</span>(T *d_it = dst, *end = dst+(size*dstIncr); d_it != end; d_it += dstIncr, src+=srcIncr)
            *d_it = *s_it;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a136f025f497da2678751fbdd97db463e"></a><!-- doxytag: member="gurls::copy_submatrix" ref="a136f025f497da2678751fbdd97db463e" args="(T *dst, const T *src, const int src_Rows, const int sizeRows, const int sizeCols, unsigned long *indices_rows, unsigned long *indices_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a136f025f497da2678751fbdd97db463e">gurls::copy_submatrix</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>src_Rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>indices_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>indices_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>output submatrix </td></tr>
    <tr><td class="paramname">src</td><td>input matrix </td></tr>
    <tr><td class="paramname">src_Rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">sizeRows</td><td>number of rows of the output submatrix </td></tr>
    <tr><td class="paramname">sizeCols</td><td>number of columns of the output submatrix </td></tr>
    <tr><td class="paramname">indices_rows</td><td>vector containing the row indices to copy (length must be == sizeRows) </td></tr>
    <tr><td class="paramname">indices_cols</td><td>vector containing the column indices to copy (length must be == sizeCols) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00331">331</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> t=0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; sizeCols; ++j)
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sizeRows; ++i)
    {
        dst[t] = src[ indices_rows[i] + indices_cols[j]*src_Rows ];
        ++t;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad606e8b3fbcbadf7bbe942cb16df301a"></a><!-- doxytag: member="gurls::copyLocations" ref="ad606e8b3fbcbadf7bbe942cb16df301a" args="(const unsigned long *locs, const T *src, const int locs_len, const int src_len, T *result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#ad606e8b3fbcbadf7bbe942cb16df301a">gurls::copyLocations</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned long *&#160;</td>
          <td class="paramname"><em>locs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>locs_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>src_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">locs</td><td>indices vector </td></tr>
    <tr><td class="paramname">src</td><td>input vector </td></tr>
    <tr><td class="paramname">locs_len</td><td>length of the indices vector </td></tr>
    <tr><td class="paramname">src_len</td><td>length of the input vector </td></tr>
    <tr><td class="paramname">result</td><td>on exit it contains a subvector with all elements of the input vector whose index is contained into <code>locs</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00895">895</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* ptr_v = result;

    <span class="keywordtype">int</span> val;
    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* l_it = locs, *l_end=locs+locs_len; l_it != l_end; ++l_it, ++ptr_v)
    {
        val = *l_it;
        <span class="keywordflow">if</span>((val &lt; 0) || (val &gt; src_len))
            <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#gaa753dbdd0384a9d49abd116b9852c651" title="Message displayed when trying to access an a vector or matrix with a too large index.">gurls::Exception_Index_Out_of_Bound</a>);

        *ptr_v = src[val];
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3286e76a0f264d9cbed8e534fce536c8"></a><!-- doxytag: member="gurls::diag" ref="a3286e76a0f264d9cbed8e534fce536c8" args="(T *vector, const int len, T *result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a3286e76a0f264d9cbed8e534fce536c8">gurls::diag</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>input vector </td></tr>
    <tr><td class="paramname">len</td><td>vector length </td></tr>
    <tr><td class="paramname">result</td><td>On exit it contains a len-by-len matrix with vector on the diagonal </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00630">630</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T zero = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.0);

    <span class="keyword">set</span>(result, zero, len*len);
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(result, vector, len, len+1, 1);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a40bfc3247c329bd81a818af3383c42c5"></a><!-- doxytag: member="gurls::distance" ref="a40bfc3247c329bd81a818af3383c42c5" args="(const T *A, const T *B, const int rows, const int A_cols, const int B_cols, T *D)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a40bfc3247c329bd81a818af3383c42c5">gurls::distance</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>B_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">B</td><td>matrix </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of both A and B </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of A </td></tr>
    <tr><td class="paramname">B_cols</td><td>number of columns of B </td></tr>
    <tr><td class="paramname">D</td><td>output A_colsxB_cols kernel matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00422">422</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">set</span>(D, (T)0.0, A_cols*B_cols);

    <span class="comment">//for i = 1:na</span>
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; A_cols; ++i)
        <span class="comment">//    for j = 1:nb</span>
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt; B_cols; ++j)
            <span class="comment">//      for k = 1:dim_a</span>
            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;rows; ++k)
            {
                <span class="comment">//          d(i,j) = d(i,j) + (a(k,i) - b(k,j))^2;</span>
                <span class="keyword">const</span> <span class="keywordtype">double</span> diff = A[k+rows*i]-B[k+rows*j];
                D[i+A_cols*j] += diff*diff;
            }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a506923827bb6ab78e9944facc9afcf13"></a><!-- doxytag: member="gurls::distance_transposed" ref="a506923827bb6ab78e9944facc9afcf13" args="(const T *A, const T *B, const int cols, const int A_rows, const int B_rows, T *D)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a506923827bb6ab78e9944facc9afcf13">gurls::distance_transposed</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>B_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">B</td><td>matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of cols of both A and B </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of A </td></tr>
    <tr><td class="paramname">B_rows</td><td>number of rows of B </td></tr>
    <tr><td class="paramname">D</td><td>output A_rowsxB_rows kernel matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00451">451</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">set</span>(D, (T)0.0, A_rows*B_rows);

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; A_rows; ++i)
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt; B_rows; ++j)
            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;cols; ++k)
            {
                <span class="comment">//          d(i,j) = d(i,j) + (a(i,k) - b(j,k))^2;</span>
                <span class="keyword">const</span> T diff = A[i+A_rows*k]-B[j+B_rows*k];
                D[i+A_rows*j] += diff*diff;
            }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a2f5abe81f955fe01b9c78e369a9f1264"></a><!-- doxytag: member="gurls::distance_transposed_vm" ref="a2f5abe81f955fe01b9c78e369a9f1264" args="(const T *A, const T *B, const int cols, const int B_rows, T *D, const int size, const int incrA=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a2f5abe81f955fe01b9c78e369a9f1264">gurls::distance_transposed_vm</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>B_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incrA</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>vector </td></tr>
    <tr><td class="paramname">B</td><td>matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of cols of both A and B </td></tr>
    <tr><td class="paramname">B_rows</td><td>number of rows of B </td></tr>
    <tr><td class="paramname">D</td><td>output of length "size" </td></tr>
    <tr><td class="paramname">size</td><td>length of vector D </td></tr>
    <tr><td class="paramname">incrA</td><td>specifies the increment for indexing vector A </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00478">478</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> j;

    <span class="comment">//#pragma omp parallel for private(j)</span>
    <span class="keywordflow">for</span>(j=0; j&lt; size; ++j)
    {
        <span class="keyword">const</span> T* B_it = B+j;
        <span class="keyword">const</span> T* A_it = A;

        T Dj = 0;

        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;cols; ++k)
        {
<span class="comment">//            d(j) = d(j) + (a(k) - b(j,k))^2;</span>
            <span class="keyword">const</span> T diff = *A_it - *B_it;
            Dj += diff*diff;

            A_it += incrA;
            B_it += B_rows;
        }

        D[j] = Dj;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="afaec98de689dfb205e909e39158b4bf3"></a><!-- doxytag: member="gurls::dot" ref="afaec98de689dfb205e909e39158b4bf3" args="(const gMat2D&lt; T &gt; &amp;A, const gMat2D&lt; T &gt; &amp;B, gMat2D&lt; T &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f">gurls::dot</a> </td>
          <td>(</td>
          <td class="paramtype">const gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Left matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>Product Matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf47db31be50bae13494a8b266524900"></a><!-- doxytag: member="gurls::dot" ref="acf47db31be50bae13494a8b266524900" args="(const gMat2D&lt; T &gt; &amp;A, const gVec&lt; T &gt; &amp;x, gVec&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f">gurls::dot</a> </td>
          <td>(</td>
          <td class="paramtype">const gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gVec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gVec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Output vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ecd2e114188dc4199f38da6eebb99dc"></a><!-- doxytag: member="gurls::dot" ref="a6ecd2e114188dc4199f38da6eebb99dc" args="(const T *A, const T *B, T *C, int A_rows, int A_cols, int B_rows, int B_cols, int C_rows, int C_cols, const CBLAS_TRANSPOSE TransA, const CBLAS_TRANSPOSE TransB, const CBLAS_ORDER Order)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f">gurls::dot</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>B_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>B_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>C_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>C_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CBLAS_TRANSPOSE&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CBLAS_TRANSPOSE&#160;</td>
          <td class="paramname"><em>TransB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CBLAS_ORDER&#160;</td>
          <td class="paramname"><em>Order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Left matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>Product Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_rows</td><td>numer of rows of the matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_cols</td><td>numer of columns of the matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_rows</td><td>numer of rows of the matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_cols</td><td>numer of columns of the matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C_rows</td><td>numer of rows of the matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C_cols</td><td>numer of columns of the matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TransA</td><td>Transposition option form matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TransB</td><td>Transposition option form matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Order</td><td>order option for matrix multiplication </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00516">516</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="keywordtype">bool</span> transposeA = (TransA == CblasTrans || TransA == CblasConjTrans);
    <span class="keywordtype">bool</span> transposeB = (TransB == CblasTrans || TransB == CblasConjTrans);

    <span class="keywordflow">if</span>(transposeA)
        <a class="code" href="../../db/d4e/namespacegurls.html#a07ed08cb9d78507e8d2c849d1cce648e" title="Template function to call BLAS *SWAP routines.">std::swap</a>(A_rows, A_cols);

    <span class="keywordflow">if</span>(transposeB)
        <a class="code" href="../../db/d4e/namespacegurls.html#a07ed08cb9d78507e8d2c849d1cce648e" title="Template function to call BLAS *SWAP routines.">std::swap</a>(B_rows, B_cols);

    <span class="keywordflow">if</span> ((C_rows != A_rows) || (C_cols != B_cols))
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#ga958853e7664e12a917823fc14b27cbe2" title="Message displayed when two arrays have inconsistent dimensions.">gurls::Exception_Inconsistent_Size</a>);

    <span class="keywordflow">if</span> (A_cols != B_rows)
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#ga958853e7664e12a917823fc14b27cbe2" title="Message displayed when two arrays have inconsistent dimensions.">gurls::Exception_Inconsistent_Size</a>);

    <span class="keyword">const</span> T alpha = 1.0;
    <span class="keyword">const</span> T beta = 0.0;

    <span class="keywordtype">int</span> lda, ldb, ldc;

    <span class="keywordtype">int</span> k = A_cols;

    <span class="comment">// mxk kxn mxn</span>

    <span class="keywordflow">switch</span>(Order)
    {
    <span class="keywordflow">case</span> CblasColMajor:

        lda = transposeA? k: A_rows;
        ldb = transposeB? B_cols: k;
        ldc = C_rows;

        <a class="code" href="../../db/d4e/namespacegurls.html#a1269a74e7f7e3d1ca200b6d8d3d0709f" title="Template function to call BLAS *GEMM routines.">gemm</a>(TransA, TransB, A_rows, B_cols, k, alpha, A, lda, B, ldb, beta, C, ldc);
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> CblasRowMajor:

        lda = transposeA? A_rows: k;
        ldb = transposeB? k: B_cols;
        ldc = C_cols;

        <a class="code" href="../../db/d4e/namespacegurls.html#a1269a74e7f7e3d1ca200b6d8d3d0709f" title="Template function to call BLAS *GEMM routines.">gemm</a>(TransB, TransA, B_cols, A_rows, k, alpha, B, ldb, A, lda, beta, C, ldc);
        <span class="keywordflow">break</span>;

    <span class="keywordflow">default</span>:
        lda = ldb = ldc = 0;
        assert(0);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aea6911142d7b74fcb892d620e3d4e836"></a><!-- doxytag: member="gurls::eig_sm" ref="aea6911142d7b74fcb892d620e3d4e836" args="(T *A, T *L, int A_rows_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#aea6911142d7b74fcb892d620e3d4e836">gurls::eig_sm</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>A_rows_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix. On exit it contains the orthonormal eigenvectors of the matrix A </td></tr>
    <tr><td class="paramname">L</td><td>vector of eigenvalues in ascending order </td></tr>
    <tr><td class="paramname">A_rows_cols</td><td>number of rows/columns of matrix A </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01444">1444</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">char</span> jobz = <span class="charliteral">&#39;V&#39;</span>;
    <span class="keywordtype">char</span> uplo = <span class="charliteral">&#39;L&#39;</span>;
    <span class="keywordtype">int</span> n = A_rows_cols, lda = n;
    <span class="keywordtype">int</span> info, lwork = 4*n;
    T* work = <span class="keyword">new</span> T[lwork];

    <a class="code" href="../../db/d4e/namespacegurls.html#a6ec8c883faab27e2907625bf8e7677da" title="Template function to call LAPACK *SYEV routines.">syev</a>(&amp;jobz, &amp;uplo, &amp;n, A, &amp;lda, L, work, &amp;lwork, &amp;info );

    <span class="keyword">delete</span>[] work;

    <span class="keywordflow">if</span>(info != 0)
    {
        std::stringstream str;
        str &lt;&lt; <span class="stringliteral">&quot;Eigenvalues/eigenVectors computation failed, error code &quot;</span> &lt;&lt; info &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> gException(str.str());
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9ad5586bb3bc80449b34f14f64c580c1"></a><!-- doxytag: member="gurls::eq" ref="a9ad5586bb3bc80449b34f14f64c580c1" args="(float val1, float val2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GURLS_EXPORT bool <a class="el" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa">gurls::eq</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialized version of eq for float values. </p>

<p>Definition at line <a class="el" href="../../d7/d27/gmath_8cpp_source.html#l00551">551</a> of file <a class="el" href="../../d7/d27/gmath_8cpp_source.html">gmath.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> ( val1 &gt;= val2-FLT_EPSILON &amp;&amp; val1 &lt;= val2+FLT_EPSILON );
}
</pre></div>
</div>
</div>
<a class="anchor" id="afd1e987bffaa4b1abad16342258bf76a"></a><!-- doxytag: member="gurls::eq" ref="afd1e987bffaa4b1abad16342258bf76a" args="(double val1, double val2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GURLS_EXPORT bool <a class="el" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa">gurls::eq</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialized version of pinv for float buffers.</p>
<p>Specialized version of eq for double values </p>

<p>Definition at line <a class="el" href="../../d7/d27/gmath_8cpp_source.html#l00542">542</a> of file <a class="el" href="../../d7/d27/gmath_8cpp_source.html">gmath.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> (val1 &gt;= val2-DBL_EPSILON &amp;&amp; val1 &lt;= val2+DBL_EPSILON );
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeeb634750e29bb441a65403a58753507"></a><!-- doxytag: member="gurls::eucl_dist" ref="aeeb634750e29bb441a65403a58753507" args="(const T *A, const T *B, const int len, T *work)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="../../db/d4e/namespacegurls.html#aeeb634750e29bb441a65403a58753507">gurls::eucl_dist</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first vector </td></tr>
    <tr><td class="paramname">B</td><td>first vector </td></tr>
    <tr><td class="paramname">len</td><td>number of element of vectors A and B </td></tr>
    <tr><td class="paramname">work</td><td>work buffer of length &gt;= <code>len</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Euclidean distance </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01487">1487</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(work, A, len);
    <a class="code" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76" title="Template function to call BLAS *AXPY routines.">axpy</a>(len, (T)-1.0, B, 1, work, 1);
    <span class="keywordflow">return</span> <a class="code" href="../../db/d4e/namespacegurls.html#afc7fa72c121304f29f5a4f6ea6874994" title="Template function to call BLAS *NRM2 routines.">nrm2</a>(len, work, 1);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4d9ac407d614639d9fe776fca148585b"></a><!-- doxytag: member="gurls::exp" ref="a4d9ac407d614639d9fe776fca148585b" args="(T *v, const int length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a4d9ac407d614639d9fe776fca148585b">gurls::exp</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector </td></tr>
    <tr><td class="paramname">length</td><td>vector size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01471">1471</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">for</span>(T *it = v, *end = v+length; it != end; ++it)
        *it = (T) <a class="code" href="../../db/d4e/namespacegurls.html#a4d9ac407d614639d9fe776fca148585b" title="In place computation of the exponential for each element of a vector.">std::exp</a>(*it);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad7448a55e9fec1102f1716192fe11547"></a><!-- doxytag: member="gurls::getRow" ref="ad7448a55e9fec1102f1716192fe11547" args="(const T *M, const int rows, const int cols, const int row_index, T *row)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547">gurls::getRow</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>input matrix </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">row_index</td><td>index of the row to be extracted </td></tr>
    <tr><td class="paramname">row</td><td>vector containing the extracted row. Length must be equal to <code>cols</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01431">1431</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(row, M+row_index, cols, 1, rows);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac628e7f04e8532e2e5846dd14f35a916"></a><!-- doxytag: member="gurls::gt" ref="ac628e7f04e8532e2e5846dd14f35a916" args="(float a, float b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GURLS_EXPORT bool <a class="el" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f">gurls::gt</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialized version of gt for double values. </p>

<p>Definition at line <a class="el" href="../../d7/d27/gmath_8cpp_source.html#l00569">569</a> of file <a class="el" href="../../d7/d27/gmath_8cpp_source.html">gmath.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> ((a - b) &gt; ( std::min(fabs(a), fabs(b))* std::numeric_limits&lt;float&gt;::epsilon()));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a502d376f316213cc2017c2c15e2924b4"></a><!-- doxytag: member="gurls::gt" ref="a502d376f316213cc2017c2c15e2924b4" args="(double a, double b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GURLS_EXPORT bool <a class="el" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f">gurls::gt</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialized version of gt for float values. </p>

<p>Definition at line <a class="el" href="../../d7/d27/gmath_8cpp_source.html#l00560">560</a> of file <a class="el" href="../../d7/d27/gmath_8cpp_source.html">gmath.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> ((a - b) &gt; ( std::min(fabs(a), fabs(b))* std::numeric_limits&lt;double&gt;::epsilon()));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8ac8d49555f8c0a752a51f302a2611e0"></a><!-- doxytag: member="gurls::indicesOfEqualsTo" ref="a8ac8d49555f8c0a752a51f302a2611e0" args="(const T *V, const int len, const T value, unsigned long *ind, int &amp;ind_length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a8ac8d49555f8c0a752a51f302a2611e0">gurls::indicesOfEqualsTo</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ind_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>input vector </td></tr>
    <tr><td class="paramname">len</td><td>number of elements of the input vector </td></tr>
    <tr><td class="paramname">value</td><td>value for comparison </td></tr>
    <tr><td class="paramname">ind</td><td>vector of the indices. Length must be &gt;= len </td></tr>
    <tr><td class="paramname">ind_length</td><td>total number of indices written into <code>ind</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01585">1585</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* r_it = ind;
    <span class="keywordflow">for</span>(<span class="keyword">const</span> T *it = V, *end = V+len; it != end; ++it)
    {
        <span class="keywordflow">if</span>(<a class="code" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa" title="&quot;Equals&quot; operator between two scalars">eq</a>(*it, value))
        {
            *r_it = it-V;
            ++r_it;
        }
    }

    ind_length = r_it - ind;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4b88bbd60e323172b176e170126583ea"></a><!-- doxytag: member="gurls::indicesOfMax" ref="a4b88bbd60e323172b176e170126583ea" args="(const T *A, const int A_rows, const int A_cols, unsigned long *ind, T *work, const int dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a4b88bbd60e323172b176e170126583ea">gurls::indicesOfMax</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">ind</td><td>vector containing computed indices, length must be A_cols if dimension == 1, or A_rows if dimension == 2 </td></tr>
    <tr><td class="paramname">work</td><td>work buffer of size &gt;= 0 if dimension == 1, or size &gt;= (A_rows*A_cols) if dimension == 2 </td></tr>
    <tr><td class="paramname">dimension</td><td>the dimension along which largest elements have to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the results vector </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01143">1143</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T *m_it;
    <span class="keywordtype">int</span> m_rows;
    <span class="keywordtype">int</span> m_cols;

    <span class="keywordflow">switch</span>(dimension)
    {
    <span class="keywordflow">case</span> 1:
        m_it = A;
        m_rows = A_rows;
        m_cols = A_cols;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 2:
        <a class="code" href="../../db/d4e/namespacegurls.html#a6d60c6fa2a1a6336ebf51e9adfbf3d7e" title="Transpose a matrix.">transpose</a>(A, A_rows, A_cols, work);
        m_it = work;
        m_rows = A_cols;
        m_cols = A_rows;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#gad52b41b606b19b5230b17dcaf36b3581" title="Message displayed when an input parameter has an invalid value.">gurls::Exception_Illegal_Argument_Value</a>);
    }

    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *r_it = ind, *r_end = ind+m_cols; r_it != r_end; ++r_it, m_it += m_rows)
        *r_it = (std::max_element(m_it, m_it+m_rows) - m_it);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a68355fb1c541564d3179538285d4673a"></a><!-- doxytag: member="gurls::lambdaguesses" ref="a68355fb1c541564d3179538285d4673a" args="(const T *eigvals, const int len, const int r, const int n, const int nlambda, const T minl)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="../../db/d4e/namespacegurls.html#a68355fb1c541564d3179538285d4673a">gurls::lambdaguesses</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>eigvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>minl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eigvals</td><td>vector containing the eigenvalues of <img class="formulaInl" alt="$X^T X$" src="../../form_46.png"/> or <img class="formulaInl" alt="$X X^T$" src="../../form_47.png"/> where <img class="formulaInl" alt="$X$" src="../../form_18.png"/> is the input data matrix </td></tr>
    <tr><td class="paramname">len</td><td>number of elements of input vector </td></tr>
    <tr><td class="paramname">r</td><td>rank </td></tr>
    <tr><td class="paramname">n</td><td>number of samples </td></tr>
    <tr><td class="paramname">nlambda</td><td></td></tr>
    <tr><td class="paramname">minl</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of values for the regularization parameter </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01226">1226</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* guesses = <span class="keyword">new</span> T[nlambda];

    T* tmp = <span class="keyword">new</span> T[len];
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(tmp, eigvals, len);

    <a class="code" href="../../db/d4e/namespacegurls.html#abb76e3d861e7dce6464e4f29c1620336" title="Sorts the elements of a matrix along the columns.">std::sort</a>(tmp, tmp+len);

    <span class="comment">/*const*/</span> T lmin = tmp[len-r];
    <span class="keyword">const</span> T lmax = tmp[len-1];

    <span class="keyword">delete</span>[] tmp;

    T thr1 = std::min(lmin, minl*lmax);
    T thr2 = 200*<span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(sqrt(std::numeric_limits&lt;T&gt;::epsilon()));

    lmin = std::max(thr1, thr2);

    <span class="keyword">const</span> T base = (lmax/lmin);
    <span class="keyword">const</span> T den = nlambda-<span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(1.0);
    <span class="keyword">const</span> T nT = (T)n;

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; nlambda; ++i)
        guesses[i] = (lmin * pow( base, ((T)i)/den ) )/nT;

    <span class="keywordflow">return</span> guesses;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2881d6d5ce35586ea88b6b485f6afa3a"></a><!-- doxytag: member="gurls::lt" ref="a2881d6d5ce35586ea88b6b485f6afa3a" args="(float a, float b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GURLS_EXPORT bool <a class="el" href="../../db/d4e/namespacegurls.html#a57330e9148465f7dad58b80361e4b510">gurls::lt</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialized version of lt for double values. </p>

<p>Definition at line <a class="el" href="../../d7/d27/gmath_8cpp_source.html#l00587">587</a> of file <a class="el" href="../../d7/d27/gmath_8cpp_source.html">gmath.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> ((b - a) &gt; ( std::max(fabs(a), fabs(b))* std::numeric_limits&lt;float&gt;::epsilon()));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a710b4faef3dc85d1e07dd6bdfbe78b30"></a><!-- doxytag: member="gurls::lt" ref="a710b4faef3dc85d1e07dd6bdfbe78b30" args="(double a, double b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GURLS_EXPORT bool <a class="el" href="../../db/d4e/namespacegurls.html#a57330e9148465f7dad58b80361e4b510">gurls::lt</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialized version of lt for float values. </p>

<p>Definition at line <a class="el" href="../../d7/d27/gmath_8cpp_source.html#l00578">578</a> of file <a class="el" href="../../d7/d27/gmath_8cpp_source.html">gmath.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> ((b - a) &gt; ( std::max(fabs(a), fabs(b))* std::numeric_limits&lt;double&gt;::epsilon()));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a73da67aa7117e56d52b5a88759cf3d78"></a><!-- doxytag: member="gurls::lu" ref="a73da67aa7117e56d52b5a88759cf3d78" args="(gMat2D&lt; T &gt; &amp;A, gVec&lt; int &gt; &amp;pv)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a2aea606f269de6a897bcfda5a11897b6">gurls::lu</a> </td>
          <td>(</td>
          <td class="paramtype">gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gVec&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). This is the right-looking Level 3 BLAS version of the algorithm. </p>

</div>
</div>
<a class="anchor" id="a32e6ab8c84d4bee2f94efedc5e8ea53a"></a><!-- doxytag: member="gurls::maxValues" ref="a32e6ab8c84d4bee2f94efedc5e8ea53a" args="(const T *A, const int A_rows, const int A_cols, T *maxv, T *work, const int dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a32e6ab8c84d4bee2f94efedc5e8ea53a">gurls::maxValues</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>maxv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">maxv</td><td>vector containing computed values, length must be A_cols if dimension == 1, or A_rows if dimension == 2 </td></tr>
    <tr><td class="paramname">work</td><td>work buffer of size &gt;= 0 if dimension == 1, or size &gt;= (A_rows*A_cols) if dimension == 2 </td></tr>
    <tr><td class="paramname">dimension</td><td>the dimension along which largest elements have to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the results vector </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01183">1183</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T *m_it;
    <span class="keywordtype">int</span> m_rows;
    <span class="keywordtype">int</span> m_cols;

    <span class="keywordflow">switch</span>(dimension)
    {
    <span class="keywordflow">case</span> 1:
        m_it = A;
        m_rows = A_rows;
        m_cols = A_cols;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 2:
        <a class="code" href="../../db/d4e/namespacegurls.html#a6d60c6fa2a1a6336ebf51e9adfbf3d7e" title="Transpose a matrix.">transpose</a>(A, A_rows, A_cols, work);
        m_it = work;
        m_rows = A_cols;
        m_cols = A_rows;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#gad52b41b606b19b5230b17dcaf36b3581" title="Message displayed when an input parameter has an invalid value.">gurls::Exception_Illegal_Argument_Value</a>);
    }

    <span class="keywordflow">for</span>(T *r_it = maxv, *r_end = maxv+m_cols; r_it != r_end; ++r_it, m_it += m_rows)
        *r_it = *std::max_element(m_it, m_it+m_rows);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a85151ab18d29196f25627917c9526088"></a><!-- doxytag: member="gurls::mean" ref="a85151ab18d29196f25627917c9526088" args="(const T *A, T *result, const int A_rows, const int A_cols, const int res_length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a85151ab18d29196f25627917c9526088">gurls::mean</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>res_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">result</td><td>vecotr of length A_cols containing mean values for each row of the matrix </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">res_length</td><td>results vector length (MUST be == A_cols) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00858">858</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="../../db/d4e/namespacegurls.html#a77ab8b750db64540cedadd69b6ba433f" title="Sums all elements along the rows of a matrix.">sum</a>(A, result, A_rows, A_cols, res_length);
    <a class="code" href="../../db/d4e/namespacegurls.html#a82615df00122dfb0d589a5a245d612be" title="Template function to call BLAS *SCAL routines.">scal</a>(res_length, (T)(1.0/A_rows), result, 1);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf1db63a5209152b935c2fbc7b7f8352"></a><!-- doxytag: member="gurls::median" ref="aaf1db63a5209152b935c2fbc7b7f8352" args="(T *v, const int length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="../../db/d4e/namespacegurls.html#aaf1db63a5209152b935c2fbc7b7f8352">gurls::median</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function does not preserve input vector.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>input vector </td></tr>
    <tr><td class="paramname">length</td><td>number of elements of the input vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01758">1758</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="../../db/d4e/namespacegurls.html#abb76e3d861e7dce6464e4f29c1620336" title="Sorts the elements of a matrix along the columns.">std::sort</a>(v, v+length);

    <span class="keywordflow">if</span>(length%2)
        <span class="keywordflow">return</span> v[length/2];
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>( (v[length/2] + v[(length/2)-1]) /2.0 );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac6c7c43939ffdc334083440d0d4b84ea"></a><!-- doxytag: member="gurls::median" ref="ac6c7c43939ffdc334083440d0d4b84ea" args="(const T *M, const int rows, const int cols, const int dimension, T *res, T *work)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#aaf1db63a5209152b935c2fbc7b7f8352">gurls::median</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>input matrix </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">res</td><td>output median values vector, size == cols if dimension == 1 or size == rows if dimension == 2 </td></tr>
    <tr><td class="paramname">work</td><td>work buffer of size &gt;= rows if dimension == 1 or &gt;= cols if dimension == 2 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01778">1778</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">switch</span>(dimension)
    {
    <span class="keywordflow">case</span> 1:
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;cols; ++i)
        {
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(work, M+(i*rows), rows);
            res[i] = <a class="code" href="../../db/d4e/namespacegurls.html#aaf1db63a5209152b935c2fbc7b7f8352" title="Returns the median value of a vector.">median</a>(work, rows);
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 2:
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;rows; ++i)
        {
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(work, M+i, cols, 1, rows);
            res[i] = <a class="code" href="../../db/d4e/namespacegurls.html#aaf1db63a5209152b935c2fbc7b7f8352" title="Returns the median value of a vector.">median</a>(work, cols);
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#gad52b41b606b19b5230b17dcaf36b3581" title="Message displayed when an input parameter has an invalid value.">Exception_Illegal_Argument_Value</a>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa4cf57d556e713079f9f556a0951486e"></a><!-- doxytag: member="gurls::mldivide_squared" ref="aa4cf57d556e713079f9f556a0951486e" args="(const T *A, T *B, const int a_rows, const int a_cols, const int b_rows, const int b_cols, const CBLAS_TRANSPOSE transA)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#aa4cf57d556e713079f9f556a0951486e">gurls::mldivide_squared</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>b_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>b_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CBLAS_TRANSPOSE&#160;</td>
          <td class="paramname"><em>transA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first input matrix </td></tr>
    <tr><td class="paramname">B</td><td>second input matrix. On exit B contains the result matrix </td></tr>
    <tr><td class="paramname">a_rows</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">a_cols</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">b_rows</td><td>number of rows of matrix B </td></tr>
    <tr><td class="paramname">b_cols</td><td>number of columns of matrix B </td></tr>
    <tr><td class="paramname">transA</td><td>specifies whether to transpose A or not </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01290">1290</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (a_cols != a_rows)
        <span class="keywordflow">throw</span> gException(<span class="stringliteral">&quot;The input matrix A must be squared&quot;</span>);

    <span class="keyword">const</span> <span class="keywordtype">int</span> lda = a_rows;
    <span class="keyword">const</span> <span class="keywordtype">int</span> ldb = b_rows;

    <a class="code" href="../../db/d4e/namespacegurls.html#a736d5bda0bca8dff4586fc1de89eedc9" title="Template function to call BLAS *TRSM routines.">trsm</a>(CblasLeft, CblasUpper, transA, CblasNonUnit, b_rows, b_cols, (T)1.0, A, lda, B, ldb);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a43a5eeef1874c15e091086b62cfcaebd"></a><!-- doxytag: member="gurls::mult" ref="a43a5eeef1874c15e091086b62cfcaebd" args="(const T *A, const T *B, T *result, const int len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a43a5eeef1874c15e091086b62cfcaebd">gurls::mult</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first input vector </td></tr>
    <tr><td class="paramname">B</td><td>second input vector </td></tr>
    <tr><td class="paramname">result</td><td>vector </td></tr>
    <tr><td class="paramname">len</td><td>vectors length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00772">772</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    binOperation&lt;T&gt;(A, B, result, len, &amp;<a class="code" href="../../db/d4e/namespacegurls.html#ac6b4396e2c97744191760e762697ae46" title="Multiplication of two scalars.">mul</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad21f1808454425473f265494395b6785"></a><!-- doxytag: member="gurls::operator&lt;&lt;" ref="ad21f1808454425473f265494395b6785" args="(std::ostream &amp;os, const GurlsOption &amp;opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GURLS_EXPORT std::ostream&amp; gurls::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GurlsOption &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes an option to a stream. </p>

<p>Definition at line <a class="el" href="../../d5/d1e/options_8cpp_source.html#l00058">58</a> of file <a class="el" href="../../d5/d1e/options_8cpp_source.html">options.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    opt.operator &lt;&lt;(os);
    <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aae1b80d6308d315bae49f7e8e5c00fd4"></a><!-- doxytag: member="gurls::pdist" ref="aae1b80d6308d315bae49f7e8e5c00fd4" args="(const T *A, const int N, const int P, T *D)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#aae1b80d6308d315bae49f7e8e5c00fd4">gurls::pdist</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rows of A correspond to observations, columns correspond to variables. D is a 1-by-(N*(N-1)/2) vector, corresponding to the N*(N-1)/2 pairs of observations in A. </p>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01502">1502</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* work = <span class="keyword">new</span> T[P];
    T* rowN = <span class="keyword">new</span> T[P];
    T* rowNPlusOne = <span class="keyword">new</span> T[P];
    T* D_it = D;

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;N-1; ++i)
    {
        <a class="code" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547" title="Generates a vector containing a copy of a row of an input matrix.">getRow</a>(A, N, P, i, rowN);

        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=i+1; j&lt;N; ++j)
        {
            <a class="code" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547" title="Generates a vector containing a copy of a row of an input matrix.">getRow</a>(A, N, P, j, rowNPlusOne);

            *D_it = <a class="code" href="../../db/d4e/namespacegurls.html#aeeb634750e29bb441a65403a58753507" title="Computes Euclidean distance between two vectors.">eucl_dist</a>(rowN,rowNPlusOne,P, work);
            ++D_it;
        }
    }

    <span class="keyword">delete</span> [] work;
    <span class="keyword">delete</span> [] rowN;
    <span class="keyword">delete</span> [] rowNPlusOne;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adfc28aaab9ad9111e413da721438370a"></a><!-- doxytag: member="gurls::pinv" ref="adfc28aaab9ad9111e413da721438370a" args="(const T *A, const int rows, const int cols, int &amp;res_rows, int &amp;res_cols, T *RCOND=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="../../db/d4e/namespacegurls.html#a753b9fab2b7733245db71f4d59bcfc9b">gurls::pinv</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>res_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>res_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>RCOND</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns </td></tr>
    <tr><td class="paramname">res_rows</td><td>on exit contains the number of rows of the pseudoinverse matrix </td></tr>
    <tr><td class="paramname">res_cols</td><td>on exit contains the number of columns of the pseudoinverse matrix </td></tr>
    <tr><td class="paramname">RCOND</td><td>used to determine the effective rank of A. If *RCOND &lt; 0, machine precision is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pseudoinverse matrix </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00423">423</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> M = rows;
    <span class="keywordtype">int</span> N = cols;

    T* a = <span class="keyword">new</span> T[rows*cols];
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(a, A, rows*cols);

    <span class="keywordtype">int</span> LDA = M;
    <span class="keywordtype">int</span> LDB = std::max(M, N);
    <span class="keywordtype">int</span> NRHS = LDB;

    <span class="keyword">const</span> <span class="keywordtype">int</span> b_size = LDB*NRHS;
    T *b = <span class="keyword">new</span> T[LDB*NRHS];

    <span class="keyword">set</span>(b, (T)0.0, b_size);
    <span class="keyword">set</span>(b, (T)1.0, std::min(LDB, NRHS), NRHS+1);

    T* S = <span class="keyword">new</span> T[std::min(M,N)];
    T rcond = (RCOND == NULL)? (std::max(rows, cols)*std::numeric_limits&lt;T&gt;::epsilon()): *RCOND;

    <span class="keywordtype">int</span> RANK = -1; <span class="comment">// std::min(M,N);</span>
    <span class="keywordtype">int</span> LWORK = -1; <span class="comment">//2 * (3*LDB + std::max( 2*std::min(M,N), LDB));</span>
    T* WORK = <span class="keyword">new</span> T[1];

    <span class="keywordtype">int</span> INFO;

    <span class="comment">/* Query and allocate the optimal workspace */</span>
    <a class="code" href="../../db/d4e/namespacegurls.html#a9c4fd96e77654eb7a8fa8e8d26d1a720" title="Template function to call LAPACK *GELSS routines.">gelss</a>( &amp;M, &amp;N, &amp;NRHS, a, &amp;LDA, b, &amp;LDB, S, &amp;rcond, &amp;RANK, WORK, &amp;LWORK, &amp;INFO);
    LWORK = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(WORK[0]);
    <span class="keyword">delete</span> [] WORK;
    WORK = <span class="keyword">new</span> T[LWORK];

    <a class="code" href="../../db/d4e/namespacegurls.html#a9c4fd96e77654eb7a8fa8e8d26d1a720" title="Template function to call LAPACK *GELSS routines.">gelss</a>( &amp;M, &amp;N, &amp;NRHS, a, &amp;LDA, b, &amp;LDB, S, &amp;rcond, &amp;RANK, WORK, &amp;LWORK, &amp;INFO);

    <span class="keyword">delete</span> [] S;
    <span class="keyword">delete</span> [] WORK;
    <span class="keyword">delete</span> [] a;

    <span class="keywordflow">if</span>(INFO != 0)
    {
        <span class="keyword">delete</span> [] b;

        std::stringstream str;
        str &lt;&lt; <span class="stringliteral">&quot;Pinv failed, error code &quot;</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> gException(str.str());
    }

    res_rows = LDB;
    res_cols = NRHS;

    <span class="keywordflow">return</span> b;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acb4047b769eb39affe91e125f8ecb6df"></a><!-- doxytag: member="gurls::precrec_driver" ref="acb4047b769eb39affe91e125f8ecb6df" args="(const T *out, const T *gt, const unsigned long N, T *work)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="../../db/d4e/namespacegurls.html#acb4047b769eb39affe91e125f8ecb6df">gurls::precrec_driver</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>vector of predicted labels </td></tr>
    <tr><td class="paramname">gt</td><td>vector of true labels </td></tr>
    <tr><td class="paramname">N</td><td>size of out and gt </td></tr>
    <tr><td class="paramname">work</td><td>Work buffer of length 4*N</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>average precision </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00092">92</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::multimap&lt;T, T, LtCompare&lt;T&gt; &gt; data;

    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; N; i++)
        data.insert(std::pair&lt;T,T&gt;(-out[i], <a class="code" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f" title="&quot;Greater than&quot; operator between two scalars">gt</a>[i]));

    <span class="keyword">typename</span> std::multimap&lt;T, T, LtCompare&lt;T&gt; &gt;::iterator it = data.begin();
    <span class="keyword">typename</span> std::multimap&lt;T, T, LtCompare&lt;T&gt; &gt;::iterator end = data.end();


    T* tp = work;
    T* fp = tp+N;
    T* prec = fp+N;
    T* rec = prec+N;

    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> tpcumsum = 0;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fpcumsum = 0;

    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> idx = 0;
    <span class="keywordflow">while</span> (it != end)
    {
        tp[idx] = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(<a class="code" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f" title="&quot;Greater than&quot; operator between two scalars">gurls::gt</a>(it-&gt;second, (T)0.0) ? tpcumsum+=1 : tpcumsum);
        fp[idx] = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(<a class="code" href="../../db/d4e/namespacegurls.html#a57330e9148465f7dad58b80361e4b510" title="&quot;Less than&quot; operator between two scalars">gurls::lt</a>(it-&gt;second, (T)0.0) ? fpcumsum+=1 : fpcumsum);

        ++it;
        ++idx;
    }

    <span class="keywordflow">for</span> (idx = 0; idx &lt; N; ++idx)
    {
        rec[idx] = tp[idx]/(T)tpcumsum;
        prec[idx] = tp[idx]/(tp[idx]+fp[idx]);
    }

    <span class="comment">// compute average precision</span>
    T ap = 0.0;
    T p = 0.0;
    T t = 0.0;

    LtCompare&lt;T&gt; comp;

    <span class="keyword">const</span> <span class="keywordtype">int</span> stepsNumber = 11;
    <span class="keyword">const</span> T incr = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.1);

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> steps = 0; steps&lt;stepsNumber; ++steps)
    {
        p = 0.0;
        <span class="keywordflow">for</span> (idx = 0; idx &lt; N; ++idx)
        {
            <span class="keywordflow">if</span> ( <a class="code" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f" title="&quot;Greater than&quot; operator between two scalars">gurls::gt</a>(rec[idx], t) || <a class="code" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa" title="&quot;Equals&quot; operator between two scalars">gurls::eq</a>(rec[idx], t))
                p = std::max&lt;T, LtCompare&lt;T&gt; &gt;(p, prec[idx], comp);
        }
        ap += p;
        t += incr;
    }

    <span class="keywordflow">return</span> ap/((T)stepsNumber);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af8659cac31df668780f9e9b022262526"></a><!-- doxytag: member="gurls::precrec_driver" ref="af8659cac31df668780f9e9b022262526" args="(const T *out, const T *gt, const unsigned long N)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="../../db/d4e/namespacegurls.html#acb4047b769eb39affe91e125f8ecb6df">gurls::precrec_driver</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>vector of predicted labels </td></tr>
    <tr><td class="paramname">gt</td><td>vector of true labels </td></tr>
    <tr><td class="paramname">N</td><td>size of out and gt</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>average precision </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00162">162</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* work = <span class="keyword">new</span> T[4*N];

    T ret = <a class="code" href="../../db/d4e/namespacegurls.html#acb4047b769eb39affe91e125f8ecb6df" title="Utility function called by the class PrecisionRecall to evaluate the average precision through precis...">precrec_driver</a>(out, <a class="code" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f" title="&quot;Greater than&quot; operator between two scalars">gt</a>, N, work);

    <span class="keyword">delete</span> [] work;

    <span class="keywordflow">return</span> ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9a5138062bf688f49c7a6d67ed71b25f"></a><!-- doxytag: member="gurls::qr_econ" ref="a9a5138062bf688f49c7a6d67ed71b25f" args="(const T *A, int m, int n, T *Q, T *R, int *E)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a9a5138062bf688f49c7a6d67ed71b25f">gurls::qr_econ</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If m &gt; n, only the first n columns of Q and the first n rows of R are computed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">m</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">n</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">Q</td><td>Q matrix </td></tr>
    <tr><td class="paramname">R</td><td>upper triangular R matrix </td></tr>
    <tr><td class="paramname">E</td><td>permutations vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01624">1624</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Q: mxmin(m,n)</span>
    <span class="comment">// R: min(m,n)xn</span>
    <span class="comment">// E: n</span>

    T* Q_tmp = <span class="keyword">new</span> T[m*n];
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(Q_tmp, A, m*n);

    <span class="keywordtype">int</span> k = std::min(m, n);

    <span class="keywordtype">int</span> lda = std::max(1,m);
    <span class="keywordtype">int</span>* jpvt = E;
    <span class="keyword">set</span>(jpvt, 0, n);

    T* tau = <span class="keyword">new</span> T[k];

    T* work;
    <span class="keywordtype">int</span> lwork = -1;
    <span class="keywordtype">int</span> info;

    <span class="comment">// query</span>
    T qwork;
    <a class="code" href="../../db/d4e/namespacegurls.html#aa0aa5f2111625115a7f28b7c408b531b" title="Template function to call LAPACK *GEQP3 routines.">geqp3</a>( &amp;m, &amp;n, Q_tmp, &amp;lda, jpvt, tau, &amp;qwork, &amp;lwork, &amp;info);

    <span class="comment">// exec</span>
    lwork = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(qwork);
    work = <span class="keyword">new</span> T[lwork];
    <a class="code" href="../../db/d4e/namespacegurls.html#aa0aa5f2111625115a7f28b7c408b531b" title="Template function to call LAPACK *GEQP3 routines.">geqp3</a>( &amp;m, &amp;n, Q_tmp, &amp;lda, jpvt, tau, work, &amp;lwork, &amp;info);

    <span class="keywordflow">if</span>(info != 0)
    {
        <span class="keyword">delete</span>[] tau;
        <span class="keyword">delete</span>[] work;
        <span class="keyword">delete</span>[] Q_tmp;

        std::stringstream str;
        str &lt;&lt; <span class="stringliteral">&quot;QR factorization failed, error code &quot;</span> &lt;&lt; info &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> gException(str.str());
    }

    <span class="keywordflow">if</span>(R != NULL)
    {
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
        {
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(R + k*i, Q_tmp + m*i, i+1);

            <span class="keyword">set</span>(R + (k*i) + i+1, (T)0.0, k - (i+1));
        }
    }

    <span class="comment">// query</span>
    lwork = -1;
    <a class="code" href="../../db/d4e/namespacegurls.html#ac37f8063b27b971d09494aaa5a41d1da" title="Template function to call LAPACK *ORGQR routines.">orgqr</a>(&amp;m, &amp;k, &amp;k, Q_tmp, &amp;lda, tau, &amp;qwork, &amp;lwork, &amp;info);

    <span class="keywordflow">if</span>(info != 0)
    {
        <span class="keyword">delete</span>[] tau;
        <span class="keyword">delete</span>[] work;
        <span class="keyword">delete</span>[] Q_tmp;

        std::stringstream str;
        str &lt;&lt; <span class="stringliteral">&quot;QR factorization failed, error code &quot;</span> &lt;&lt; info &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> gException(str.str());
    }

    <span class="comment">//exec</span>
    lwork = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(qwork);
    <span class="keyword">delete</span>[] work;
    work = <span class="keyword">new</span> T[lwork];
    <a class="code" href="../../db/d4e/namespacegurls.html#ac37f8063b27b971d09494aaa5a41d1da" title="Template function to call LAPACK *ORGQR routines.">orgqr</a>(&amp;m, &amp;k, &amp;k, Q_tmp, &amp;lda, tau, work, &amp;lwork, &amp;info);

    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(Q, Q_tmp, m*k);

    <span class="keyword">delete</span>[] tau;
    <span class="keyword">delete</span>[] work;
    <span class="keyword">delete</span>[] Q_tmp;

}
</pre></div>
</div>
</div>
<a class="anchor" id="adf6dc7afcc579ec3a85a1b7e29962c4c"></a><!-- doxytag: member="gurls::random_svd" ref="adf6dc7afcc579ec3a85a1b7e29962c4c" args="(const T *A, const unsigned long A_rows, const unsigned long A_cols, T *U, T *S, T *V, unsigned long k=6, unsigned long its=2, unsigned long l=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#adf6dc7afcc579ec3a85a1b7e29962c4c">gurls::random_svd</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>k</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>its</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>l</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix </td></tr>
    <tr><td class="paramname">A_rows</td><td>Number of rows of A </td></tr>
    <tr><td class="paramname">A_cols</td><td>Number of columns of A </td></tr>
    <tr><td class="paramname">U</td><td>Matrix </td></tr>
    <tr><td class="paramname">S</td><td>Matrix </td></tr>
    <tr><td class="paramname">V</td><td>Matrix </td></tr>
    <tr><td class="paramname">k</td><td>Rank, must be a positive integer &lt;= the smallest dimension of A. </td></tr>
    <tr><td class="paramname">its</td><td>Iterations of Lanczos method </td></tr>
    <tr><td class="paramname">l</td><td>Block size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00520">520</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// U: (A_rows,k)</span>
    <span class="comment">// S: (k)</span>
    <span class="comment">// V: (A_cols, k)</span>

    <span class="keywordflow">if</span>(l &lt; k)
        l = k+2;

    <span class="keywordflow">if</span>((k &gt; A_rows) || (k &gt; A_cols))
        <span class="keywordflow">throw</span> gException(<span class="stringliteral">&quot;k must be &lt;= the smallest dimension of A&quot;</span>);

<span class="comment">//    %</span>
<span class="comment">//    % SVD A directly if (its+1)*l &gt;= m/1.25 or (its+1)*l &gt;= n/1.25.</span>
<span class="comment">//    %</span>

<span class="comment">//    if(((its+1)*l &gt;= m/1.25) || ((its+1)*l &gt;= n/1.25))</span>

    <span class="keyword">const</span> T thr1 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(A_rows/1.25);
    <span class="keyword">const</span> T thr2 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(A_cols/1.25);
    <span class="keyword">const</span> T block_dim = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>((its+1)*l);

    <span class="keywordflow">if</span>(<a class="code" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f" title="&quot;Greater than&quot; operator between two scalars">gt</a>(block_dim, thr1) || <a class="code" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa" title="&quot;Equals&quot; operator between two scalars">eq</a>(block_dim, thr1) || <a class="code" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f" title="&quot;Greater than&quot; operator between two scalars">gt</a>(block_dim, thr2) || <a class="code" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa" title="&quot;Equals&quot; operator between two scalars">eq</a>(block_dim, thr2))
    {
<span class="comment">//        [U,S,V] = svd(A,&#39;econ&#39;);</span>
        T *Q, *L, *Vt;
        <span class="keywordtype">int</span> Q_rows, Q_cols;
        <span class="keywordtype">int</span> L_len;
        <span class="keywordtype">int</span> Vt_rows, Vt_cols;

        <a class="code" href="../../db/d4e/namespacegurls.html#ac363704394a8b83cc1929f35864064ef" title="Implements the SVD decomposition of a general rectangular matrix: A = U*W*Vt.">svd</a>(A, Q, L, Vt, A_rows, A_cols, Q_rows, Q_cols, L_len, Vt_rows, Vt_cols, <span class="keyword">true</span>);

<span class="comment">//    %</span>
<span class="comment">//    % Retain only the leftmost k columns of U, the leftmost k columns of V,</span>
<span class="comment">//    % and the uppermost leftmost k x k block of S.</span>
<span class="comment">//    %</span>

<span class="comment">//      U = U(:,1:k);</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(U, Q, k*Q_rows);
        <span class="keyword">delete</span>[] Q;

<span class="comment">//      S = S(1:k,1:k);</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(S, L, k);
        <span class="keyword">delete</span>[] L;

<span class="comment">//      V = V(:,1:k);</span>
        <span class="keywordflow">if</span>(V != NULL)
        {
            T* tr = <span class="keyword">new</span> T[Vt_cols*Vt_rows];

            <a class="code" href="../../db/d4e/namespacegurls.html#a6d60c6fa2a1a6336ebf51e9adfbf3d7e" title="Transpose a matrix.">transpose</a>(Vt, Vt_rows, Vt_cols, tr);

            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(V, tr, k*Vt_cols);
            <span class="keyword">delete</span>[] tr;
        }
        <span class="keyword">delete</span>[] Vt;

        <span class="keywordflow">return</span>;
    }

    <span class="keyword">const</span> T randMax = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(RAND_MAX);
    <span class="keyword">const</span> T one = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(1.0);
    <span class="keyword">const</span> T two = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(2.0);

<span class="comment">//    if(m &gt;= n)</span>
    <span class="keywordflow">if</span>(A_rows &gt;= A_cols)
    {
        <span class="keyword">const</span> <span class="keywordtype">int</span> H_len = A_rows*l;

        T* H = <span class="keyword">new</span> T[H_len];
        T* tmp = <span class="keyword">new</span> T[A_cols*l];

<span class="comment">//    %</span>
<span class="comment">//    % Apply A to a random matrix, obtaining H.</span>
<span class="comment">//    %</span>
<span class="comment">//        H = A*(2*rand(n,l)-ones(n,l));</span>
        <span class="keywordflow">for</span>(T *it =tmp, *end = tmp +(A_cols*l); it != end; ++it)
            *it = (two* rand()/randMax) - one;

        <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(A, tmp, H, A_rows, A_cols, A_cols, l, A_rows, l, CblasNoTrans, CblasNoTrans, CblasColMajor);

<span class="comment">//    %</span>
<span class="comment">//    % Initialize F to its final size and fill its leftmost block with H.</span>
<span class="comment">//    %</span>
<span class="comment">//      F(1:m, 1:l) = H;</span>
        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> F_cols = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(block_dim);
        T* F = <span class="keyword">new</span> T[A_rows*F_cols];
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(F, H, H_len);

<span class="comment">//    %</span>
<span class="comment">//    % Apply A*A&#39; to H a total of its times,</span>
<span class="comment">//    % augmenting F with the new H each time.</span>
<span class="comment">//    %</span>

<span class="comment">//      for it = 1:its</span>
        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iter = 1; iter&lt;=its; ++iter)
        {
<span class="comment">//        H = (H&#39;*A)&#39;;</span>
<span class="comment">//        H = A*H;</span>
            <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(H, A, tmp, A_rows, l, A_rows, A_cols, l, A_cols, CblasTrans, CblasNoTrans, CblasColMajor);
            <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(A, tmp, H, A_rows, A_cols, l, A_cols, A_rows, l, CblasNoTrans, CblasTrans, CblasColMajor);

<span class="comment">//        F(1:m, (1+it*l):((it+1)*l)) = H;</span>
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(F + (H_len*iter), H, H_len);
        }

        <span class="keyword">delete</span>[] H;

<span class="comment">//    %</span>
<span class="comment">//    % Form a matrix Q whose columns constitute an orthonormal basis</span>
<span class="comment">//    % for the columns of F.</span>
<span class="comment">//    %</span>
<span class="comment">//      [Q,R,E] = qr(F,0);</span>
        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Q_cols = std::min(A_rows, F_cols);
        T* Q = <span class="keyword">new</span> T[A_rows*Q_cols];
        T* R = NULL;
        <span class="keywordtype">int</span>* E = <span class="keyword">new</span> <span class="keywordtype">int</span> [F_cols];

        <a class="code" href="../../db/d4e/namespacegurls.html#a9a5138062bf688f49c7a6d67ed71b25f" title="Computes an economy-size QR decomposition of an input matrix A so that A(:,E) = Q*R.">qr_econ</a>(F, A_rows, F_cols, Q, R, E);

        <span class="keyword">delete</span>[] E;
        <span class="keyword">delete</span>[] F;

<span class="comment">//    %</span>
<span class="comment">//    % SVD Q&#39;*A to obtain approximations to the singular values</span>
<span class="comment">//    % and right singular vectors of A; adjust the left singular vectors</span>
<span class="comment">//    % of Q&#39;*A to approximate the left singular vectors of A.</span>
<span class="comment">//    %</span>
<span class="comment">//      [U2,S,V] = svd(Q&#39;*A,&#39;econ&#39;);</span>
        T *U2, *L, *Vt;
        <span class="keywordtype">int</span> U2_rows, U2_cols;
        <span class="keywordtype">int</span> L_len;
        <span class="keywordtype">int</span> Vt_rows, Vt_cols;

        <span class="keyword">delete</span>[] tmp;
        tmp = <span class="keyword">new</span> T[Q_cols*A_cols];

        <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(Q, A, tmp, A_rows, Q_cols, A_rows, A_cols, Q_cols, A_cols, CblasTrans, CblasNoTrans, CblasColMajor);
        <a class="code" href="../../db/d4e/namespacegurls.html#ac363704394a8b83cc1929f35864064ef" title="Implements the SVD decomposition of a general rectangular matrix: A = U*W*Vt.">svd</a>(tmp , U2, L, Vt, Q_cols, A_cols, U2_rows, U2_cols, L_len, Vt_rows, Vt_cols, <span class="keyword">true</span>);

<span class="comment">//      U = Q*U2;</span>
        <span class="keyword">delete</span>[] tmp;
        tmp = <span class="keyword">new</span> T[A_rows*U2_cols];
        <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(Q, U2, tmp, A_rows, Q_cols, U2_rows, U2_cols, A_rows, U2_cols, CblasNoTrans, CblasNoTrans, CblasColMajor);

<span class="comment">//      clear Q U2;</span>
        <span class="keyword">delete</span>[] Q;
        <span class="keyword">delete</span>[] U2;

<span class="comment">//    %</span>
<span class="comment">//    % Retain only the leftmost k columns of U, the leftmost k columns of V,</span>
<span class="comment">//    % and the uppermost leftmost k x k block of S.</span>
<span class="comment">//    %</span>
<span class="comment">//      U = U(:,1:k);</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(U, tmp, k*A_rows);
        <span class="keyword">delete</span>[] tmp;

<span class="comment">//      V = V(:,1:k);</span>
        <span class="keywordflow">if</span>(V != NULL)
        {
            T* tr = <span class="keyword">new</span> T[Vt_cols*Vt_rows];

            <a class="code" href="../../db/d4e/namespacegurls.html#a6d60c6fa2a1a6336ebf51e9adfbf3d7e" title="Transpose a matrix.">transpose</a>(Vt, Vt_rows, Vt_cols, tr);

            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(V, tr, k*Vt_cols);
            <span class="keyword">delete</span>[] tr;
        }
        <span class="keyword">delete</span>[] Vt;


<span class="comment">//      S = S(1:k,1:k);</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(S, L, k);
        <span class="keyword">delete</span>[] L;

    }
    <span class="keywordflow">else</span>
    {
<span class="comment">//        %</span>
<span class="comment">//        % Apply A&#39; to a random matrix, obtaining H.</span>
<span class="comment">//        %</span>

        <span class="keyword">const</span> <span class="keywordtype">int</span> H_len = A_cols*l;

<span class="comment">//            H = ((2*rand(l,m)-ones(l,m))*A)&#39;;</span>
        T* H = <span class="keyword">new</span> T[H_len];
        T* tmp = <span class="keyword">new</span> T[l*A_rows];

        <span class="keywordflow">for</span>(T *it =tmp, *end = tmp +(l*A_rows); it != end; ++it)
            *it = (two* rand()/randMax) - one;

        <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(A, tmp, H, A_rows, A_cols, l, A_rows, A_cols, l, CblasTrans, CblasTrans, CblasColMajor);


<span class="comment">//        %</span>
<span class="comment">//        % Initialize F to its final size and fill its leftmost block with H.</span>
<span class="comment">//        %</span>
<span class="comment">//          F = zeros(n,(its+1)*l);</span>
<span class="comment">//          F(1:n, 1:l) = H;</span>

        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> F_cols = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(block_dim);
        T* F = <span class="keyword">new</span> T[A_cols*F_cols];
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(F, H, H_len);

<span class="comment">//        %</span>
<span class="comment">//        % Apply A&#39;*A to H a total of its times,</span>
<span class="comment">//        % augmenting F with the new H each time.</span>
<span class="comment">//        %</span>
<span class="comment">//          for it = 1:its</span>
        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iter = 1; iter&lt;=its; ++iter)
        {
<span class="comment">//            H = A*H;</span>
            <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(A, H, tmp, A_rows, A_cols, A_cols, l, A_rows, l, CblasNoTrans, CblasNoTrans, CblasColMajor);

<span class="comment">//            H = (H&#39;*A)&#39;;</span>
            <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(A, tmp, H, A_rows, A_cols, A_rows, l, A_cols, l, CblasTrans, CblasNoTrans, CblasColMajor);

<span class="comment">//            F(1:n, (1+it*l):((it+1)*l)) = H;</span>
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(F + (H_len*iter), H, H_len);
        }

        <span class="keyword">delete</span>[] H;

<span class="comment">//        %</span>
<span class="comment">//        % Form a matrix Q whose columns constitute an orthonormal basis</span>
<span class="comment">//        % for the columns of F.</span>
<span class="comment">//        %</span>

<span class="comment">//          [Q,R,E] = qr(F,0);</span>
        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Q_cols = std::min(A_cols, F_cols);
        T* Q = <span class="keyword">new</span> T[A_cols*Q_cols];
        T* R = NULL;
        <span class="keywordtype">int</span>* E = <span class="keyword">new</span> <span class="keywordtype">int</span> [F_cols];

        <a class="code" href="../../db/d4e/namespacegurls.html#a9a5138062bf688f49c7a6d67ed71b25f" title="Computes an economy-size QR decomposition of an input matrix A so that A(:,E) = Q*R.">qr_econ</a>(F, A_cols, F_cols, Q, R, E);

        <span class="keyword">delete</span>[] E;
        <span class="keyword">delete</span>[] F;

<span class="comment">//        %</span>
<span class="comment">//        % SVD A*Q to obtain approximations to the singular values</span>
<span class="comment">//        % and left singular vectors of A; adjust the right singular vectors</span>
<span class="comment">//        % of A*Q to approximate the right singular vectors of A.</span>
<span class="comment">//        %</span>

<span class="comment">//          [U,S,V2] = svd(A*Q,&#39;econ&#39;);</span>
        T *U2, *L, *Vt;
        <span class="keywordtype">int</span> U2_rows, U2_cols;
        <span class="keywordtype">int</span> L_len;
        <span class="keywordtype">int</span> Vt_rows, Vt_cols;

        <span class="keyword">delete</span>[] tmp;
        tmp = <span class="keyword">new</span> T[A_rows*Q_cols];

        <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(A, Q, tmp, A_rows, A_cols, A_cols, Q_cols, A_rows, Q_cols, CblasNoTrans, CblasNoTrans, CblasColMajor);
        <a class="code" href="../../db/d4e/namespacegurls.html#ac363704394a8b83cc1929f35864064ef" title="Implements the SVD decomposition of a general rectangular matrix: A = U*W*Vt.">svd</a>(tmp, U2, L, Vt, A_rows, Q_cols, U2_rows, U2_cols, L_len, Vt_rows, Vt_cols, <span class="keyword">true</span>);

<span class="comment">//          V = Q*V2;</span>
        <span class="keyword">delete</span>[] tmp;
        <span class="keywordflow">if</span>(V != NULL)
        {
            tmp = <span class="keyword">new</span> T[A_cols*Vt_rows];
            <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(Q, Vt, tmp, A_cols, Q_cols, Vt_rows, Vt_cols, A_cols, Vt_rows, CblasNoTrans, CblasTrans, CblasColMajor);
        }

        <span class="keyword">delete</span>[] Vt;
        <span class="keyword">delete</span>[] Q;

<span class="comment">//        %</span>
<span class="comment">//        % Retain only the leftmost k columns of U, the leftmost k columns of V,</span>
<span class="comment">//        % and the uppermost leftmost k x k block of S.</span>
<span class="comment">//        %</span>

<span class="comment">//          U = U(:,1:k);</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(U, U2, k*U2_rows);
        <span class="keyword">delete</span>[] U2;

<span class="comment">//          V = V(:,1:k);</span>
        <span class="keywordflow">if</span>(V != NULL)
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(V, tmp, k*A_cols);

        <span class="keyword">delete</span>[] tmp;

<span class="comment">//          S = S(1:k,1:k);</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(S, L, k);
        <span class="keyword">delete</span>[] L;

    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a53b8a878e025a9aecca369bfdd383dcc"></a><!-- doxytag: member="gurls::rdivide" ref="a53b8a878e025a9aecca369bfdd383dcc" args="(const T *A, const T *B, T *result, const int len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a53b8a878e025a9aecca369bfdd383dcc">gurls::rdivide</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first input vector </td></tr>
    <tr><td class="paramname">B</td><td>second input vector </td></tr>
    <tr><td class="paramname">result</td><td>vector </td></tr>
    <tr><td class="paramname">len</td><td>vectors length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00786">786</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    binOperation&lt;T&gt;(A, B, result, len, &amp;<a class="code" href="../../db/d4e/namespacegurls.html#ac21e7810d76da1d8374506562d4bc1fe" title="Division of two scalars.">div</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0cd2d49089ac88dd5ccf4b91e3b97bff"></a><!-- doxytag: member="gurls::rls_eigen" ref="a0cd2d49089ac88dd5ccf4b91e3b97bff" args="(const T *Q, const T *L, const T *Qty, T *C, const T lambda, const int n, const int Q_rows, const int Q_cols, const int L_length, const int Qty_rows, const int Qty_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a0cd2d49089ac88dd5ccf4b91e3b97bff">gurls::rls_eigen</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Q_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Q_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>L_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Qty_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Qty_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>eigenvectors of the kernel matrix </td></tr>
    <tr><td class="paramname">L</td><td>eigenvalues of the kernel matrix </td></tr>
    <tr><td class="paramname">Qty</td><td>result of the matrix multiplication of the transpose of Q times the labels vector Y <img class="formulaInl" alt="$(Q^T Y)$" src="../../form_45.png"/> </td></tr>
    <tr><td class="paramname">C</td><td>on exit contains the rls coefficients matrix </td></tr>
    <tr><td class="paramname">lambda</td><td>regularization parameter </td></tr>
    <tr><td class="paramname">n</td><td>number of training samples </td></tr>
    <tr><td class="paramname">Q_rows</td><td>number of rows of the matrix Q </td></tr>
    <tr><td class="paramname">Q_cols</td><td>number of columns of the matrix Q </td></tr>
    <tr><td class="paramname">L_length</td><td>number of elements of the vector L </td></tr>
    <tr><td class="paramname">Qty_rows</td><td>number of rows of the matrix Qty </td></tr>
    <tr><td class="paramname">Qty_cols</td><td>number of columns of the matrix Qty </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00940">940</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* work = <span class="keyword">new</span> T [(Q_rows+1)*L_length];

    <a class="code" href="../../db/d4e/namespacegurls.html#a0cd2d49089ac88dd5ccf4b91e3b97bff" title="Computes RLS estimator given the singular value decomposition of the kernel matrix.">rls_eigen</a>(Q, L, Qty, C, lambda, n, Q_rows, Q_cols, L_length, Qty_rows, Qty_cols, work);

    <span class="keyword">delete</span> [] work;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab2fc16e3ae966dc22dc6e4ad8ab4ed0d"></a><!-- doxytag: member="gurls::rls_eigen" ref="ab2fc16e3ae966dc22dc6e4ad8ab4ed0d" args="(const T *Q, const T *L, const T *Qty, T *C, const T lambda, const int n, const int Q_rows, const int Q_cols, const int L_length, const int Qty_rows, const int Qty_cols, T *work)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a0cd2d49089ac88dd5ccf4b91e3b97bff">gurls::rls_eigen</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Q_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Q_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>L_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Qty_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Qty_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>eigenvectors of the kernel matrix </td></tr>
    <tr><td class="paramname">L</td><td>eigenvalues of the kernel matrix </td></tr>
    <tr><td class="paramname">Qty</td><td>result of the matrix multiplication of the transpose of Q times the labels vector Y <img class="formulaInl" alt="$(Q^T Y)$" src="../../form_45.png"/> </td></tr>
    <tr><td class="paramname">C</td><td>on exit contains the rls coefficients matrix </td></tr>
    <tr><td class="paramname">lambda</td><td>regularization parameter </td></tr>
    <tr><td class="paramname">n</td><td>number of training samples </td></tr>
    <tr><td class="paramname">Q_rows</td><td>number of rows of the matrix Q </td></tr>
    <tr><td class="paramname">Q_cols</td><td>number of columns of the matrix Q </td></tr>
    <tr><td class="paramname">L_length</td><td>number of elements of the vector L </td></tr>
    <tr><td class="paramname">Qty_rows</td><td>number of rows of the matrix Qty </td></tr>
    <tr><td class="paramname">Qty_cols</td><td>number of columns of the matrix Qty </td></tr>
    <tr><td class="paramname">work</td><td>Work buffer of length L_length*(Q_rows+1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00969">969</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//function C = rls_eigen(Q,L,QtY,lambda,n)</span>

    <span class="comment">//sQ = size(Q,1); -&gt; Q_rows</span>

    <span class="comment">//L = L + n*lambda;</span>
    T* L1 = work; <span class="comment">// size L_length</span>

    <span class="keyword">set</span>(L1, n*lambda , L_length);

    <a class="code" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76" title="Template function to call BLAS *AXPY routines.">axpy</a>(L_length, (T)1.0, L, 1, L1, 1);

    <span class="comment">//L = L.^(-1);</span>
    <a class="code" href="../../db/d4e/namespacegurls.html#a153b5476d7a4deb157db95079469c2cb" title="Computes the element-by-element multiplicative inverse of an input matrix.">setReciprocal</a>(L1, L_length);

    <span class="comment">// L = diag(L)</span>
    T* QL = work+L_length; <span class="comment">// size Q_rows*L_length</span>

    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(QL, Q, Q_rows*Q_cols);
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; Q_cols; ++i)
        <a class="code" href="../../db/d4e/namespacegurls.html#a82615df00122dfb0d589a5a245d612be" title="Template function to call BLAS *SCAL routines.">scal</a>(Q_rows, L1[i], QL+(Q_rows*i), 1);

    <span class="comment">//C = (Q*L)*QtY;</span>
    <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(QL, Qty, C, Q_rows, L_length, Qty_rows, Qty_cols, Q_rows, Qty_cols, CblasNoTrans, CblasNoTrans, CblasColMajor);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf3d4c52d803726cffe2b9ae96fd7e12"></a><!-- doxytag: member="gurls::rls_pegasos_driver" ref="aaf3d4c52d803726cffe2b9ae96fd7e12" args="(const T *X, const T *bY, const GurlsOptionsList &amp;opt, const int X_rows, const int X_cols, const int bY_rows, const int bY_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d34/classgurls_1_1_gurls_options_list.html">GurlsOptionsList</a>* <a class="el" href="../../db/d4e/namespacegurls.html#aaf3d4c52d803726cffe2b9ae96fd7e12">gurls::rls_pegasos_driver</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>bY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GurlsOptionsList &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>X_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>X_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bY_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bY_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>input data matrix </td></tr>
    <tr><td class="paramname">bY</td><td>labels matrix </td></tr>
    <tr><td class="paramname">opt</td><td>options </td></tr>
    <tr><td class="paramname">X_rows</td><td>number of rows in X </td></tr>
    <tr><td class="paramname">X_cols</td><td>number of columns in X </td></tr>
    <tr><td class="paramname">bY_rows</td><td>number of rows in bY </td></tr>
    <tr><td class="paramname">bY_cols</td><td>number of columns in bY</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>updates the the field optimizer in opt by changing the following fields:<ul>
<li>W = matrix of coefficient vectors of rls estimator for each class</li>
<li>W_sum = sum of the classifiers across iterations</li>
<li>count = number of iterations</li>
<li>acc_last = accuracy of the solution computed in the last iteration</li>
<li>acc_avg = average accuracy across iterations </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00192">192</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//  lambda = opt.singlelambda(opt.paramsel.lambdas);</span>
    <span class="keyword">const</span> gMat2D&lt;T&gt; &amp;ll = opt.getOptValue&lt;OptMatrix&lt;gMat2D&lt;T&gt; &gt; &gt;(<span class="stringliteral">&quot;paramsel.lambdas&quot;</span>);
    T lambda = opt.getOptAs&lt;OptFunction&gt;(<span class="stringliteral">&quot;singlelambda&quot;</span>)-&gt;getValue(ll.getData(), ll.getSize());


<span class="comment">//            [n,d] = size(X);</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = X_rows;
    <span class="keyword">const</span> <span class="keywordtype">int</span> d = X_cols;

<span class="comment">//            [T] = size(bY,2);</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> t = bY_cols;


<span class="comment">//            cfr = opt.cfr;</span>

<span class="comment">//            W = cfr.W; %dxT</span>
    <span class="keyword">const</span> GurlsOptionsList* optimizer = opt.getOptAs&lt;GurlsOptionsList&gt;(<span class="stringliteral">&quot;optimizer&quot;</span>);

    <span class="keyword">const</span> gMat2D&lt;T&gt; &amp;W_mat = optimizer-&gt;getOptValue&lt;OptMatrix&lt;gMat2D&lt;T&gt; &gt; &gt;(<span class="stringliteral">&quot;W&quot;</span>);
    gMat2D&lt;T&gt; *W = <span class="keyword">new</span> gMat2D&lt;T&gt;(W_mat.rows(), W_mat.cols());
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(W-&gt;getData(), W_mat.getData(), W_mat.getSize());

<span class="comment">//            W_sum = cfr.W_sum;</span>
    <span class="keyword">const</span> gMat2D&lt;T&gt; &amp;W_sum_mat = optimizer-&gt;getOptValue&lt;OptMatrix&lt;gMat2D&lt;T&gt; &gt; &gt;(<span class="stringliteral">&quot;W_sum&quot;</span>);
    gMat2D&lt;T&gt; *W_sum = <span class="keyword">new</span> gMat2D&lt;T&gt;(W_sum_mat.rows(), W_sum_mat.cols());
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(W_sum-&gt;getData(), W_sum_mat.getData(), W_sum_mat.getSize());

<span class="comment">//            count = cfr.count;</span>
    <span class="keywordtype">int</span> count = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(optimizer-&gt;getOptAsNumber(<span class="stringliteral">&quot;count&quot;</span>));

<span class="comment">//            t0 = cfr.t0;</span>
    T t0 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(optimizer-&gt;getOptAsNumber(<span class="stringliteral">&quot;t0&quot;</span>));


    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> * seq = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>[n];
    T* xt = <span class="keyword">new</span> T[d];
    T* y_hat = <span class="keyword">new</span> T[t];
    T* r = <span class="keyword">new</span> T[t];
    <span class="keyword">const</span> <span class="keywordtype">int</span> W_size = d*t;
    T* xtr = <span class="keyword">new</span> T[W_size];

<span class="comment">//            %% Initialization</span>
<span class="comment">//            iter = 0;</span>
    <span class="keywordtype">int</span> iter;

    <span class="keyword">const</span> T thr = sqrt(t/lambda);

<span class="comment">//            seq = randperm(n);</span>
    <a class="code" href="../../db/d4e/namespacegurls.html#a75f6afe3bf7f7be79d66714593f5c7bc" title="Generates a vector containing a random permutation of the values from start to start+n inclusive...">randperm</a>(n, seq);

    <span class="keywordflow">for</span>(iter = 0; iter&lt;n; ++iter)
    {
<span class="comment">//            while iter &lt; n,</span>
<span class="comment">//                iter = iter + 1;</span>
<span class="comment">//                idx = seq(iter);</span>
        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> idx = seq[iter];

<span class="comment">//                %% Stepsize</span>

<span class="comment">//                %% Update Equations</span>
<span class="comment">//                xt = X(idx,:); %1xd</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547" title="Generates a vector containing a copy of a row of an input matrix.">getRow</a>(X, n, d, idx, xt);

<span class="comment">//                y_hat = (xt*W); %1xT</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(xt, W-&gt;getData(), y_hat, 1, d, d, t, 1, t, CblasNoTrans, CblasNoTrans, CblasColMajor);

<span class="comment">//                r = bY(idx,:) - y_hat; %1xT</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547" title="Generates a vector containing a copy of a row of an input matrix.">getRow</a>(bY, bY_rows, t, idx, r);
        <a class="code" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76" title="Template function to call BLAS *AXPY routines.">axpy</a>(t, (T)-1.0, y_hat, 1, r, 1);


<span class="comment">//                eta = 1.0/(lambda*(count + t0));</span>
        <span class="keyword">const</span> T eta = ((T)1.0)/(lambda*(count + t0));

<span class="comment">//                W = (1 - lambda*eta)*W + eta*xt&#39;*r; %dxT</span>
        <span class="keyword">const</span> T coeff = (T)1.0 - (lambda*eta);

        <a class="code" href="../../db/d4e/namespacegurls.html#a82615df00122dfb0d589a5a245d612be" title="Template function to call BLAS *SCAL routines.">scal</a>(W_size, coeff, W-&gt;getData(), 1);

        <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(xt, r, xtr, d, 1, 1, t, d, t, CblasNoTrans, CblasNoTrans, CblasColMajor);

        <a class="code" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76" title="Template function to call BLAS *AXPY routines.">axpy</a>(W_size, eta, xtr, 1, W-&gt;getData(), 1);

<span class="comment">//                %% Projection onto the ball with radius sqrt(T/lambda)</span>
<span class="comment">//                nW = norm(W,&#39;fro&#39;); %Frobenius norm</span>

        T tmp = <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(W_size, W-&gt;getData(), 1, W-&gt;getData(), 1);
        T  nW = sqrt(tmp);


        <span class="comment">//                if nW &gt; sqrt(T/lambda)</span>
        <span class="keywordflow">if</span>( <a class="code" href="../../db/d4e/namespacegurls.html#a4c4b44477c465507bbe9ec446b40a71f" title="&quot;Greater than&quot; operator between two scalars">gt</a>(nW, thr) )
        {
            <span class="comment">//                    W = (W/nW)*sqrt(T/lambda);</span>
            <span class="keyword">set</span>(xtr, (T)0.0, W_size);
            <a class="code" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76" title="Template function to call BLAS *AXPY routines.">axpy</a>(W_size, thr/nW, W-&gt;getData(), 1, xtr, 1);
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(W-&gt;getData(), xtr, W_size);
        }

<span class="comment">//                %% Averaging</span>

<span class="comment">//                W_sum = W_sum + W;</span>
        <a class="code" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76" title="Template function to call BLAS *AXPY routines.">axpy</a>(W_size, (T)1.0, W-&gt;getData(), 1, W_sum-&gt;getData(), 1);

<span class="comment">//                count = count + 1;</span>
        ++count;

<span class="comment">//                %% Testing</span>
<span class="comment">//                if(mod(count,n) == 1)</span>
<span class="comment">//                    fprintf(&#39;\n\tObjective : %f&#39;,obj_primal(W, X, bY, lambda));</span>
<span class="comment">//                    cfr.acc_last(end+1) = test_classifier (W,opt);</span>
<span class="comment">//                    fprintf(&#39;\n\tLast Acc: %f&#39;, cfr.acc_last(end));</span>
<span class="comment">//                    cfr.acc_avg(end+1) = test_classifier (W_sum/count,opt);</span>
<span class="comment">//                    fprintf(&#39;\n\tAvg Acc: %f\n&#39;, cfr.acc_avg(end));</span>
<span class="comment">//                end</span>

    }

    <span class="keyword">delete</span>[] seq;
    <span class="keyword">delete</span>[] xt;
    <span class="keyword">delete</span>[] y_hat;
    <span class="keyword">delete</span>[] r;
    <span class="keyword">delete</span>[] xtr;

    GurlsOptionsList* ret = <span class="keyword">new</span> GurlsOptionsList(<span class="stringliteral">&quot;optimizer&quot;</span>);

<span class="comment">//            cfr.W = W;</span>
    ret-&gt;addOpt(<span class="stringliteral">&quot;W&quot;</span>, <span class="keyword">new</span> OptMatrix&lt;gMat2D&lt;T&gt; &gt;(*W));

<span class="comment">//            cfr.W_last = W;</span>

<span class="comment">//            cfr.W_sum = W_sum;</span>
    ret-&gt;addOpt(<span class="stringliteral">&quot;W_sum&quot;</span>, <span class="keyword">new</span> OptMatrix&lt;gMat2D&lt;T&gt; &gt;(*W_sum));

<span class="comment">//            cfr.count = count;</span>
    ret-&gt;addOpt(<span class="stringliteral">&quot;count&quot;</span>, <span class="keyword">new</span> OptNumber(count));

<span class="comment">//            cfr.iter = iter;</span>
    ret-&gt;addOpt(<span class="stringliteral">&quot;iter&quot;</span>, <span class="keyword">new</span> OptNumber(iter));

    ret-&gt;addOpt(<span class="stringliteral">&quot;t0&quot;</span>, <span class="keyword">new</span> OptNumber(t0));

    <span class="comment">//  cfr.C = [];</span>
    gMat2D&lt;T&gt;* emptyC = <span class="keyword">new</span> gMat2D&lt;T&gt;();
    ret-&gt;addOpt(<span class="stringliteral">&quot;C&quot;</span>, <span class="keyword">new</span> OptMatrix&lt;gMat2D&lt;T&gt; &gt;(*emptyC));

    <span class="comment">//  cfr.X = [];</span>
    gMat2D&lt;T&gt;* emptyX = <span class="keyword">new</span> gMat2D&lt;T&gt;();
    ret-&gt;addOpt(<span class="stringliteral">&quot;X&quot;</span>, <span class="keyword">new</span> OptMatrix&lt;gMat2D&lt;T&gt; &gt;(*emptyX));

    <span class="keywordflow">return</span> ret;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b510185d90e724e1b848aa7fe000612"></a><!-- doxytag: member="gurls::set" ref="a2b510185d90e724e1b848aa7fe000612" args="(T *buffer, const T value, const int size, const int incr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a2b510185d90e724e1b848aa7fe000612">gurls::set</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>vector to be set </td></tr>
    <tr><td class="paramname">value</td><td>value to set </td></tr>
    <tr><td class="paramname">size</td><td>number of copy operations to be performed </td></tr>
    <tr><td class="paramname">incr</td><td>number of element to skip after every copy (if incr == 1 all elements will be set) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a055f95a43e117399de4db553fe1154e2"></a><!-- doxytag: member="gurls::set" ref="a055f95a43e117399de4db553fe1154e2" args="(T *buffer, const T value, const int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a2b510185d90e724e1b848aa7fe000612">gurls::set</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>vector to be set </td></tr>
    <tr><td class="paramname">value</td><td>value to set </td></tr>
    <tr><td class="paramname">size</td><td>buffer length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00240">240</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">for</span>(T *it = buffer, *end = buffer+size; it != end; ++it)
        *it = value;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a153b5476d7a4deb157db95079469c2cb"></a><!-- doxytag: member="gurls::setReciprocal" ref="a153b5476d7a4deb157db95079469c2cb" args="(T *matrix, const int len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a153b5476d7a4deb157db95079469c2cb">gurls::setReciprocal</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>input matrix </td></tr>
    <tr><td class="paramname">len</td><td>number of matrix elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00614">614</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T one = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(1.0);

    <span class="keywordflow">for</span>(T *it = matrix, *end = matrix+len; it != end; ++it)
        *it = one / *it;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1722b64bc35b5a0a8ed920bd41a182f4"></a><!-- doxytag: member="gurls::sign" ref="a1722b64bc35b5a0a8ed920bd41a182f4" args="(const T *vector, const int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="../../db/d4e/namespacegurls.html#a1722b64bc35b5a0a8ed920bd41a182f4">gurls::sign</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<ul>
<li>1 if the corresponding element of the input vector is greater than zero</li>
<li>0 if the corresponding element of the input vector is zero</li>
<li>-1 if the corresponding element of the input vector is less than zero</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>input vector </td></tr>
    <tr><td class="paramname">size</td><td>number of elements of the input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the signum vector </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01010">1010</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T* v_it = vector;
    <span class="keyword">const</span> T* v_end = vector+size;

    T* ret = <span class="keyword">new</span> T[size];
    T* r_it = ret;

    <span class="keyword">const</span> T zero = (T)0.0;

    <span class="keywordflow">while</span>(v_it != v_end)
    {
        *r_it = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>((<a class="code" href="../../db/d4e/namespacegurls.html#a043f387ab664c3ac5b96aed7b7f748aa" title="&quot;Equals&quot; operator between two scalars">eq</a>(*v_it, zero)? 0.0 : ((*v_it &gt; 0.0)? 1.0 : -1.0)));

        ++v_it;
        ++r_it;
    }

    <span class="keywordflow">return</span> ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abb76e3d861e7dce6464e4f29c1620336"></a><!-- doxytag: member="gurls::sort" ref="abb76e3d861e7dce6464e4f29c1620336" args="(const T *M, const unsigned long rows, const unsigned long cols, bool(*pred)(T, T), T *values, unsigned long *indices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#abb76e3d861e7dce6464e4f29c1620336">gurls::sort</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(T, T)&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Input matrix </td></tr>
    <tr><td class="paramname">rows</td><td>Matrix rows </td></tr>
    <tr><td class="paramname">cols</td><td>Matrix columns </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate used for comparison </td></tr>
    <tr><td class="paramname">values</td><td>On ouptut contains the ordered values matrix </td></tr>
    <tr><td class="paramname">indices</td><td>On ouptut contains the ordered indices matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01102">1102</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">typedef</span> std::multimap&lt;T, unsigned long, bool(*)(T,T) &gt; MapType;

    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i=0; i&lt; rows; ++i)
    {
        MapType data(pred);

        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j = 0; j &lt; cols; ++j)
        {
            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> index = i+(rows*j);
            data.insert( std::pair&lt;T,unsigned long&gt;(M[index], j));
        }

        <span class="keyword">typename</span> MapType::iterator it = data.begin();

        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j = 0; j &lt; cols; ++j, ++it)
        {
            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> index = i+(rows*j);

            <span class="keywordflow">if</span>(values != NULL)
                values[index] = it-&gt;first;

            <span class="keywordflow">if</span>(indices != NULL)
                indices[index] = it-&gt;second;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2edac8fc521c5bb7e91c90f1bbe80172"></a><!-- doxytag: member="gurls::squareform" ref="a2edac8fc521c5bb7e91c90f1bbe80172" args="(const T *A, const int N, const int P, T *D, const int d_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a2edac8fc521c5bb7e91c90f1bbe80172">gurls::squareform</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If A is a vector as created by the pdist function, converts A into a symmetric, square format, so that D(i,j) denotes the distance between the i and j objects in the original data. If A is a symmetric, square matrix with zeros along the diagonal, creates a vector D containing the A elements below the diagonal. D has the same format as the output from the PDIST function. </p>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01538">1538</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span>(d_cols!=1)
    {
        T* work = <span class="keyword">new</span> T[P];
        T* rowN = <span class="keyword">new</span> T[P];
        T* rowNPlusOne = <span class="keyword">new</span> T[P];

        <span class="keyword">set</span>(D, (T)0.0, N, N+1); <span class="comment">// zeroes the diagonal</span>

        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;N; ++i)
        {
            <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(D+(i*N), D+i, i, 1, N); <span class="comment">// copy from the other side</span>

            <span class="keywordflow">if</span>(i+1 &lt; N)
            {
                <a class="code" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547" title="Generates a vector containing a copy of a row of an input matrix.">getRow</a>(A, N, P, i, rowN);

                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=i+1; j&lt;N; ++j)
                {
                    <a class="code" href="../../db/d4e/namespacegurls.html#ad7448a55e9fec1102f1716192fe11547" title="Generates a vector containing a copy of a row of an input matrix.">getRow</a>(A, N, P, j, rowNPlusOne);
                    D[j + i*N] = <a class="code" href="../../db/d4e/namespacegurls.html#aeeb634750e29bb441a65403a58753507" title="Computes Euclidean distance between two vectors.">eucl_dist</a>(rowN, rowNPlusOne, P, work);
                }
            }
        }

        <span class="keyword">delete</span> [] work;
        <span class="keyword">delete</span> [] rowN;
        <span class="keyword">delete</span> [] rowNPlusOne;

    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="../../db/d4e/namespacegurls.html#aae1b80d6308d315bae49f7e8e5c00fd4" title="Computes a vector D containing the Euclidean distances between each pair of observations in the N-by-...">pdist</a>(A, N, P, D);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac18259120405abd399d5dccf5c9735fb"></a><!-- doxytag: member="gurls::stdDev" ref="ac18259120405abd399d5dccf5c9735fb" args="(const T *X, const int rows, const int cols, T *res, T *work)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#ac18259120405abd399d5dccf5c9735fb">gurls::stdDev</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>input matrix </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">res</td><td>output standard deviations vector </td></tr>
    <tr><td class="paramname">work</td><td>work buffer of size &gt;= cols+rows </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01733">1733</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* meanX = work;
    <a class="code" href="../../db/d4e/namespacegurls.html#a85151ab18d29196f25627917c9526088" title="Computes the mean values along the rows of a matrix.">mean</a>(X, meanX, rows, cols, cols);

    T* stdX = res;
    T* column = work+cols;

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; cols; ++i)
    {
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(column, X+(rows*i), rows);

        <a class="code" href="../../db/d4e/namespacegurls.html#a82ee9c80ec97ed26a84b7d311a2cef76" title="Template function to call BLAS *AXPY routines.">axpy</a>(rows, (T)-1.0, meanX+i, 0, column, 1);

        stdX[i] = sqrt( pow(<a class="code" href="../../db/d4e/namespacegurls.html#afc7fa72c121304f29f5a4f6ea6874994" title="Template function to call BLAS *NRM2 routines.">nrm2</a>(rows, column, 1), 2) / (rows-1));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaed8f970da9e1fc94319ba8579b88986"></a><!-- doxytag: member="gurls::subMatrixFromColumns" ref="aaed8f970da9e1fc94319ba8579b88986" args="(const T *matrix, const int mRows, const int mCols, const unsigned long *colsIndices, const int nIndices, T *submat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#aaed8f970da9e1fc94319ba8579b88986">gurls::subMatrixFromColumns</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long *&#160;</td>
          <td class="paramname"><em>colsIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>submat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>input matrix </td></tr>
    <tr><td class="paramname">mRows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">mCols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">colsIndices</td><td>vector containing the columns indices to copy </td></tr>
    <tr><td class="paramname">nIndices</td><td>length of the indices vector </td></tr>
    <tr><td class="paramname">submat</td><td>output submatrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00374">374</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span>(mCols &lt; nIndices)
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#ga958853e7664e12a917823fc14b27cbe2" title="Message displayed when two arrays have inconsistent dimensions.">Exception_Inconsistent_Size</a>);

    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *it = colsIndices, *end = colsIndices+nIndices; it != end; ++it)
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(submat+(mRows*(it-colsIndices)), matrix+(mRows*(*it)), mRows);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4015e8417bc5f4375da5524d7b67338c"></a><!-- doxytag: member="gurls::subMatrixFromRows" ref="a4015e8417bc5f4375da5524d7b67338c" args="(const T *matrix, const int mRows, const int mCols, const unsigned long *rowsIndices, const int nIndices, T *submat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a4015e8417bc5f4375da5524d7b67338c">gurls::subMatrixFromRows</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long *&#160;</td>
          <td class="paramname"><em>rowsIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>submat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>input matrix </td></tr>
    <tr><td class="paramname">mRows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">mCols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">rowsIndices</td><td>vector containing the row indices to copy </td></tr>
    <tr><td class="paramname">nIndices</td><td>length of the indices vector </td></tr>
    <tr><td class="paramname">submat</td><td>output submatrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00353">353</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span>(mRows &lt; nIndices)
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#ga958853e7664e12a917823fc14b27cbe2" title="Message displayed when two arrays have inconsistent dimensions.">Exception_Inconsistent_Size</a>);

    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *it = rowsIndices, *end = rowsIndices+nIndices; it != end; ++it)
        <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(submat + (it-rowsIndices), matrix+(*it), mCols, nIndices, mRows);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a77ab8b750db64540cedadd69b6ba433f"></a><!-- doxytag: member="gurls::sum" ref="a77ab8b750db64540cedadd69b6ba433f" args="(const T *A, T *result, const int A_rows, const int A_cols, const int res_length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a77ab8b750db64540cedadd69b6ba433f">gurls::sum</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>res_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">result</td><td>vecotr of length A_cols containing sums for each row of the matrix </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">res_length</td><td>results vector length (MUST be == A_cols) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00801">801</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span>(A_cols != res_length)
        <span class="keywordflow">throw</span> gException(<a class="code" href="../../d1/dc9/group___exceptions.html#ga958853e7664e12a917823fc14b27cbe2" title="Message displayed when two arrays have inconsistent dimensions.">Exception_Inconsistent_Size</a>);

    <span class="keyword">const</span> T *a_it = A, *a_end;

    <span class="keyword">const</span> T zero = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.0);

    <span class="keywordflow">for</span>(T *r_it = result, *r_end = result+A_cols; r_it != r_end; ++r_it)
    {
        *r_it = zero;
        a_end = a_it+A_rows;

        <span class="keywordflow">while</span>(a_it != a_end)
        {
            *r_it += *a_it;

            ++a_it;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ad5abc1e6f16da6c801ad8a93dfb731"></a><!-- doxytag: member="gurls::sum_col" ref="a6ad5abc1e6f16da6c801ad8a93dfb731" args="(const T *A, T *result, const int A_rows, const int A_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a6ad5abc1e6f16da6c801ad8a93dfb731">gurls::sum_col</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">result</td><td>vecotr of length A_rows containing sums for each column of the matrix </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of matrix A </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00833">833</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> T *a_it = A, *a_end;

    <span class="keyword">const</span> T zero = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.0);

    <span class="keywordflow">for</span>(T *r_it = result, *r_end = result+A_rows; r_it != r_end; ++r_it)
    {
        *r_it = zero;

        <span class="keywordflow">for</span>(a_it = A+(r_it-result), a_end = a_it+(A_cols*A_rows); a_it != a_end; a_it += A_rows)
            *r_it += *a_it;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2f1802e90fc6d89dcc35bfef3c369250"></a><!-- doxytag: member="gurls::sumv" ref="a2f1802e90fc6d89dcc35bfef3c369250" args="(const T *V, const int len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="../../db/d4e/namespacegurls.html#a2f1802e90fc6d89dcc35bfef3c369250">gurls::sumv</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>input vector </td></tr>
    <tr><td class="paramname">len</td><td>vector length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sum of all elements of the input vector </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00918">918</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T y = 1;
    <span class="keywordflow">return</span> <a class="code" href="../../db/d4e/namespacegurls.html#a3f47b50b7b9a1b985181888eaeead53f" title="Template function to call BLAS *DOT routines.">dot</a>(len, V, 1, &amp;y, 0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac363704394a8b83cc1929f35864064ef"></a><!-- doxytag: member="gurls::svd" ref="ac363704394a8b83cc1929f35864064ef" args="(const gMat2D&lt; T &gt; &amp;A, gMat2D&lt; T &gt; &amp;U, gVec&lt; T &gt; &amp;W, gMat2D&lt; T &gt; &amp;Vt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#ac363704394a8b83cc1929f35864064ef">gurls::svd</a> </td>
          <td>(</td>
          <td class="paramtype">const gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gVec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gMat2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix to be decomposed </td></tr>
    <tr><td class="paramname">U</td><td>Matrix of the left singular vectors </td></tr>
    <tr><td class="paramname">W</td><td>Vector containing the singular values of the decomposition </td></tr>
    <tr><td class="paramname">Vt</td><td>transposed matrix of the right singular vectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89bed76dd7920ad067ca0f5548feafdd"></a><!-- doxytag: member="gurls::svd" ref="a89bed76dd7920ad067ca0f5548feafdd" args="(const T *A, T *&amp;U, T *&amp;S, T *&amp;Vt, const int A_rows, const int A_cols, int &amp;U_rows, int &amp;U_cols, int &amp;S_len, int &amp;Vt_rows, int &amp;Vt_cols, bool econ=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#ac363704394a8b83cc1929f35864064ef">gurls::svd</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>Vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>A_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>U_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>U_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>S_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Vt_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Vt_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>econ</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="../../d1/d29/classgurls_1_1g_exception.html">gException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input matrix to be decomposed </td></tr>
    <tr><td class="paramname">U</td><td>Matrix of the left singular vectors </td></tr>
    <tr><td class="paramname">S</td><td>Vector containing the singular values of the decomposition </td></tr>
    <tr><td class="paramname">Vt</td><td>transposed matrix of the right singular vectors </td></tr>
    <tr><td class="paramname">A_rows</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">A_cols</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">U_rows</td><td>number of rows of matrix U </td></tr>
    <tr><td class="paramname">U_cols</td><td>number of columns of matrix U </td></tr>
    <tr><td class="paramname">S_len</td><td>number of elements of vector S </td></tr>
    <tr><td class="paramname">Vt_rows</td><td>number of rows of matrix Vt </td></tr>
    <tr><td class="paramname">Vt_cols</td><td>number of columns of matrix Vt </td></tr>
    <tr><td class="paramname">econ</td><td>if true computes the "economy size" decomposition. If A_rows &gt;= A_cols, then svd computes only the first A_cols columns of U and S length is A_cols. For A_rows &lt; A_cols, only the first A_rows rows of Vt are computed and S length is A_rows. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l01324">1324</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// A = U*S*Vt</span>

    <span class="keywordtype">char</span> jobu, jobvt;

    <span class="keywordtype">int</span> m = A_rows;
    <span class="keywordtype">int</span> n = A_cols;
    <span class="keywordtype">int</span> k = std::min&lt;int&gt;(m, n);
    <span class="keywordtype">int</span> ldvt;

    S = <span class="keyword">new</span> T[k];
    S_len = k;

    U_rows = m;
    Vt_cols = n;

    <span class="keywordflow">if</span>(econ)
    {
<span class="comment">//        jobu = jobvt = &#39;S&#39;;</span>
        <span class="keywordflow">if</span>(m&gt;n)
        {
            jobu = <span class="charliteral">&#39;S&#39;</span>;
            jobvt = <span class="charliteral">&#39;A&#39;</span>;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m&lt;n)
        {
            jobu = <span class="charliteral">&#39;A&#39;</span>;
            jobvt = <span class="charliteral">&#39;S&#39;</span>;
        }
        <span class="keywordflow">else</span>
            jobu = jobvt = <span class="charliteral">&#39;S&#39;</span>;

        U = <span class="keyword">new</span> T[m*k];
        Vt = <span class="keyword">new</span> T[k*n];

        U_cols = k;
        Vt_rows = k;

        ldvt = k;
    }
    <span class="keywordflow">else</span>
    {
        jobu = jobvt = <span class="charliteral">&#39;A&#39;</span>;

        U = <span class="keyword">new</span> T[m*m];
        Vt = <span class="keyword">new</span> T[n*n];

        U_cols = m;
        Vt_rows = n;

        ldvt = n;
    }

    <span class="comment">//MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N))</span>

    <span class="keywordtype">int</span> lda = A_rows;
    <span class="keywordtype">int</span> ldu = m;
    <span class="keywordtype">int</span> info, lwork = std::max&lt;int&gt;(3*k+std::max&lt;int&gt;(m,n), 5*k);
    T* work = <span class="keyword">new</span> T[lwork];
    T* cpy = <span class="keyword">new</span> T[m*n];
    <a class="code" href="../../db/d4e/namespacegurls.html#acf8c56c7e1dddb56e5b6b65fcb817ded" title="Copies element form one vector to another one.">copy</a>(cpy, A, A_rows*A_cols);

    <a class="code" href="../../db/d4e/namespacegurls.html#aab6cd9a9688f9d62ee51cf92fb4dac5d" title="Template function to call BLAS *GESVD routines.">gesvd_</a>(&amp;jobu, &amp;jobvt, &amp;m, &amp;n, cpy, &amp;lda, S, U, &amp;ldu, Vt, &amp;ldvt, work, &amp;lwork, &amp;info);

    <span class="keyword">delete</span>[] work;
    <span class="keyword">delete</span>[] cpy;

    <span class="keywordflow">if</span>(info != 0)
    {
        std::stringstream str;
        str &lt;&lt; <span class="stringliteral">&quot;SVD failed, error code &quot;</span> &lt;&lt; info &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> gException(str.str());
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2270d88158df11a01a89f70dead4986c"></a><!-- doxytag: member="gurls::TASKDESC_SEPARATOR" ref="a2270d88158df11a01a89f70dead4986c" args="(&quot;:&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string <a class="el" href="../../db/d4e/namespacegurls.html#a2270d88158df11a01a89f70dead4986c">gurls::TASKDESC_SEPARATOR</a> </td>
          <td>(</td>
          <td class="paramtype">&quot;:&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>"&lt;task_desc&gt;TASKDESC_SEPARATOR&lt;task_name&gt;") </p>

</div>
</div>
<a class="anchor" id="ade3f4598bd1adbc6b009209aa409635e"></a><!-- doxytag: member="gurls::test_classifier" ref="ade3f4598bd1adbc6b009209aa409635e" args="(T *W, GurlsOptionsList &amp;opt, const int rows, const int cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="../../db/d4e/namespacegurls.html#ade3f4598bd1adbc6b009209aa409635e">gurls::test_classifier</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GurlsOptionsList &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>coefficient vector for a linear classifier </td></tr>
    <tr><td class="paramname">opt</td><td>options with the followng fields:<ul>
<li>Xte</li>
<li>yte </li>
</ul>
</td></tr>
    <tr><td class="paramname">rows</td><td>number of rows in W </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns in W</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>res classification accuracy </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d60/utils_8h_source.html#l00365">365</a> of file <a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//opt.rls.W = W;</span>

    GurlsOptionsList* optimizer = GurlsOptionsList::dynacast(opt.getOpt(<span class="stringliteral">&quot;optimizer&quot;</span>));

    gMat2D&lt;T&gt; *W_mat = NULL;
    <span class="keywordflow">if</span>(!optimizer-&gt;hasOpt(<span class="stringliteral">&quot;W&quot;</span>))
    {
        W_mat = <span class="keyword">new</span> gMat2D&lt;T&gt;(rows,cols);
        optimizer-&gt;addOpt(<span class="stringliteral">&quot;W&quot;</span>, <span class="keyword">new</span> OptMatrix&lt;gMat2D&lt;T&gt; &gt;(*W_mat));
    }
    <span class="keywordflow">else</span>
    {
        GurlsOption *W_opt = optimizer-&gt;getOpt(<span class="stringliteral">&quot;W&quot;</span>);
        W_mat = &amp;(OptMatrix&lt;gMat2D&lt;T&gt; &gt;::dynacast(W_opt))-&gt;getValue();
    }

    gMat2D&lt;T&gt; W_t(W, W_mat-&gt;cols(), W_mat-&gt;rows(), <span class="keyword">false</span>);
    W_t.transpose(*W_mat);

    GurlsOption *x = opt.getOpt(<span class="stringliteral">&quot;Xte&quot;</span>);
    gMat2D&lt;T&gt;* X = &amp;(OptMatrix&lt; gMat2D&lt;T&gt; &gt;::dynacast(x))-&gt;getValue();
    GurlsOption *y = opt.getOpt(<span class="stringliteral">&quot;yte&quot;</span>);
    gMat2D&lt;T&gt;* Y = &amp;(OptMatrix&lt; gMat2D&lt;T&gt; &gt;::dynacast(y))-&gt;getValue();

    <span class="comment">//opt.pred = pred_primal(opt.Xte, opt.yte, opt);</span>
    PredPrimal&lt;T&gt; pp;
    pp.execute(*X, *Y, opt);

    <span class="comment">//opt.perf   = perf_macroavg(opt.Xte, opt.yte, opt);</span>
    PerfMacroAvg&lt;T&gt; ma;
    ma.execute(*X, *Y, opt);

    <span class="comment">//acc = mean([opt.perf.acc]);</span>
    GurlsOptionsList* perf = GurlsOptionsList::dynacast(opt.getOpt(<span class="stringliteral">&quot;perf&quot;</span>));
    GurlsOption *perf_opt = perf-&gt;getOpt(<span class="stringliteral">&quot;acc&quot;</span>);
    gMat2D&lt;T&gt; *acc_mat = &amp;(OptMatrix&lt;gMat2D&lt;T&gt; &gt;::dynacast(perf_opt))-&gt;getValue();

    T res;
    mean&lt;T&gt;(acc_mat-&gt;getData(), &amp;res, 1, acc_mat-&gt;getSize(), 1);

    <span class="keywordflow">return</span> res;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d60c6fa2a1a6336ebf51e9adfbf3d7e"></a><!-- doxytag: member="gurls::transpose" ref="a6d60c6fa2a1a6336ebf51e9adfbf3d7e" args="(const T *matrix, const int rows, const int cols, T *transposed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d4e/namespacegurls.html#a6d60c6fa2a1a6336ebf51e9adfbf3d7e">gurls::transpose</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>transposed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>input matrix to be transposed </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns of the input matrix </td></tr>
    <tr><td class="paramname">transposed</td><td>on exit contains the transposed matrix. Must be already initialized with a number of rows and columns equal to the number of columns and rows of the input matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d75/gmath_8h_source.html#l00487">487</a> of file <a class="el" href="../../dd/d75/gmath_8h_source.html">gmath.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* d1 = transposed;
    <span class="keyword">const</span> T* d0 = matrix;
    <span class="keyword">const</span> <span class="keywordtype">int</span> N = rows;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; rows; ++r)
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; cols; ++c)
            *d1++=*(d0+c*N+r);
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a11d0fc7949708ef68897305433953b8b"></a><!-- doxytag: member="gurls::MAX_PRINTABLE_SIZE" ref="a11d0fc7949708ef68897305433953b8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../db/d4e/namespacegurls.html#a11d0fc7949708ef68897305433953b8b">gurls::MAX_PRINTABLE_SIZE</a> = 200<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Verctor with a largest size will not be printed out </p>

<p>Definition at line <a class="el" href="../../db/d7e/basearray_8h_source.html#l00064">64</a> of file <a class="el" href="../../db/d7e/basearray_8h_source.html">basearray.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../db/d4e/namespacegurls.html">gurls</a>      </li>

    <li class="footer">Generated on Fri Jul 26 2013 11:31:45 for GURLS++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
